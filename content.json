{"meta":{"title":"Hai的BLOG","subtitle":"ImmNaruto","description":"个人博客","author":"DH","url":"http://immnaruto.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-11-21T08:43:50.000Z","updated":"2020-11-27T08:01:51.016Z","comments":false,"path":"about/index.html","permalink":"http://immnaruto.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-21T07:17:13.000Z","updated":"2020-11-21T09:26:00.663Z","comments":false,"path":"categories/index.html","permalink":"http://immnaruto.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-21T07:19:42.000Z","updated":"2020-11-21T09:25:48.898Z","comments":false,"path":"tags/index.html","permalink":"http://immnaruto.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"生活随笔","slug":"生活随笔","date":"2020-11-29T15:35:18.212Z","updated":"2020-11-30T04:10:05.880Z","comments":true,"path":"2020-11-29-生活随笔.html","link":"","permalink":"http://immnaruto.github.io/2020-11-29-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94.html","excerpt":"1我好像是个怀旧的人。","text":"1我好像是个怀旧的人。 高中三年想着初中，大学三年想着高中，听歌还全是老歌，以至于现在天天循环从初中开始听了七年的歌（写随笔的时候听的是许嵩的《庐州月》)…说实话，我一点都没有变，只是在努力地适应着生活。 而我身边的人不这样。 今天晚上，一个高中的好朋友给我分享了一个链接，标题是：国家奖学金获得者XXX（她本人），一路前行，嘴上说着祝贺，心里略微有了一点苦涩。是啊，相比起其他人的大学，我真的太普通不过了。说着是在计算机专业学习，但是内心对什么都很排斥，想着在自己的小天地，碌碌无为，好吃懒做，在这个高手如云的专业，甚至都排不上号，看着别人一步步变得更好，自己剩下的只有无力。 之前看到老番茄的毕业视频，其中有一幕是登台演讲的时候，灯光都聚集在他的身上，弹幕都在说他在发光，也许我也曾渴望自己来到大学是这个模样，但三年过去了，一点没变。 一时不知道说什么下去了，祝大家在自己的世界里，都熠熠发光吧。 2 《熬夜冠军》凌晨两点半，某男生宿舍。 睡不着的我翻来覆去，刷着视频，一会儿上个厕所，一会坐起来喝水…熬夜人常态。 本来以为是个平常的一天，但今天不一样。 两点半，坐起身，准备上厕所时候，临铺突然支起身子来，好像在看我。我试探性的叫了一声“凡凡”，因为这种事不是一次两次了，而且刚刚还说着梦话。没想到，得到了应答：睡不着。 我一阵偷笑，拍了拍他，说早点睡，下了床。唯一的下铺今天也灯火通明（没睡）。 我也拍了拍他，说睡吧。 上完厕所爬上床，感觉到了一丝欣慰。因为，我不再是孤军奋战了（doge） 于是今天四点半才睡着… 下次一定不熬夜了！！！！","categories":[{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"HDU操作系统实验一","slug":"HDU操作系统实验一","date":"2020-11-27T06:16:49.146Z","updated":"2020-11-29T15:28:26.101Z","comments":true,"path":"2020-11-27-HDU操作系统实验一.html","link":"","permalink":"http://immnaruto.github.io/2020-11-27-HDU%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80.html","excerpt":"HDU操作系统实验一一、实验要求 添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级。建议调用原型是int mysetnice(pid_t pid, int flag, int nicevalue, void_user* prio, void_user* nice)参数含义：","text":"HDU操作系统实验一一、实验要求 添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级。建议调用原型是int mysetnice(pid_t pid, int flag, int nicevalue, void_user* prio, void_user* nice)参数含义： pid：进程IDflag：若为0，则表示读取nice的值；若为1，则表示修改nice的值。nicevalue：为指定的进程设置新的nice。prio，nice：指向进程的优先级和nice值。返回值：系统调用成功时返回0；失败时返回错误码EFAULT。 写一个简单的应用程序测试（1）中添加的系统调用。 若系统调用了Linux的内核函数，要求深入阅读相关的源码。 二、实验思路 个人理解为通过修改系统调用表实现系统调用（即调用系统自带函数），例如c语言的头文件。 通过将调用例程写入内核并编译内核，完成所述要求。 三、实验步骤 前期准备工作 虚拟机上需要安装ubuntu，本人安装了Ubuntu 16.04.2，配置要求有两点： 内存分配40G以上 CPU分配4核（双核双线程） 安装好后，还需要去官网下载linux内核源码，本人下载的版本是linux-4.16.3.tar.xz，传到虚拟机中，解压出来即可。 分配系统调用号，修改系统调用表 查看系统调用表(linux-4.16.3/arch/x86/entry/syscalls/syscall_64.tbl) 在这里我们需要选择一个未使用过的系统调用号进行分配，当前系统使用到332号，所以我们选择新添加的系统调用号为333号。 声明系统调用服务例程 Linux系统调用服务例程的原型申明在文件 (./include/linux/syscalls.h) 中，我们可以添加如图所示的内容 每个系统调用都对应一个内核服务例程来实现该系统调用的具体功能，其命名格式都是以“sys_”开头。其中“asmlinkage”是一个必须的限定词，用于通知编译器仅从堆栈中提取该函数的参数，而不是从寄存器中，因为在执行服务例程之前系统已经将通过寄存器传递过来的参数值压入内核堆栈了。 实现系统调用服务 下面为新调用的 mysetnice 编写服务例程 sys_dhsyscall， 通常添加在 sys.c 文件中，其路径为 (./kernel/sys.c )。 1234567891011121314151617181920212223SYSCALL_DEFINE5(dhsyscall,pid_t,pid,int,flag,int,nicevalue,void __user*,prio,void __user*,nice)&#123; struct pid * kpid; struct task_struct * pcb; kpid = find_get_pid(pid);/* 返回pid */ pcb = pid_task(kpid, PIDTYPE_PID);/* 返回task_struct */ int now_nice,now_prio; if(flag == 1) &#123; set_user_nice(pcb, nicevalue);/* 修改进程nice值 */ &#125; else if(flag != 0) &#123; return EFAULT; &#125; now_prio = task_prio(pcb);/*返回进程当前prio值*/ now_nice = task_nice(pcb);/*重新取得进程nice值*/ copy_to_user(nice,&amp; now_nice,sizeof(now_nice));/*将nice值拷贝到用户空间*/ copy_to_user(prio,&amp; now_prio,sizeof(now_prio));/*将prio值拷贝到用户空间*/ return 0;&#125; 这是一个简单的实现读取进程 nice 值和修改进行 nice 值的服务。当参数 flag 为 0 的时候读取 nice 值，并将数据从内核空间拷贝到用户空间。当 flag 为 1 的时候修改 nice 值为 nicevalue 的值。 在新版本的内核中，引入了宏“SYSCALL_DEFINEN(sname)”对服务例程原型进行了封装，其中的“N”是该系统调用所需要参数的个数， 在这里我们使用了 5 个参数所以是 DEFINE5。 编译内核 清除残留的.config 和.o 文件 编译出错需要重新编译或不是第一次编译，都需要清除残留的.config 和.o 文件，方法是进入Linux内核所在的子目录， 执行以下命令： 1# make mrproper 这里可能会提醒安装 ncurses 包，在 ubuntu 中 ncurses 库的名字是 libncurses5-dev，安装命令是： 1# apt-get install libncurses5-dev 配置内核 执行命令 1# make menuconfig 运行该命令过程中，可能会报错提示缺少一个套件 ncurses devel，那么你需要手动对其进行安装，安装方法同上安装 ncurses 包的过程。 在执行 make menuconfig 命令的时候会出现一个配置对话框，我们一般采用默认值：选择保存配置信息，然后选择退出对话框。 编译内核，生成启动映像文件 内核配置完后，编译内核，生成启动映像文件 bzlmage ，位于 (./arch/x86_64/boot/bzlmage) 中，执行命令： 1# make 这里也许会提示没有安装 openssl，安装的方法如下： 1# apt-get install libssl-dev 内核编译时间可能较长，视硬件配置而定，一般情况为2小时左右 编译模块 1# make modules 安装模块/内核 12# make modules_install# make install 配置 grub 引导程序 1# update-grub2 重启系统 1# reboot 重启系统后，可以通过终端来查看新内核的版本。输入如下指令 1uname -r 观察显示的内核版本是否与编译的内核版本一致。 编写用户态测试程序 测试程序如下： test.c 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdio.h&gt;#define _SYSCALL_dhsyscall_ 333#define EFALUT 14 /*这里linux中错误码EFAULT的值为14*/int main()&#123; int pid, flag, nicevalue; int prev_prio, prev_nice, cur_prio, cur_nice; int result; printf(&quot;请输入PID flag nicevalue: &quot;); scanf(&quot;%d%d%d&quot;, &amp;pid, &amp;flag, &amp;nicevalue); result = syscall(_SYSCALL_dhsyscall_, pid, 0, nicevalue, &amp;prev_prio, &amp;prev_nice); if (result == EFALUT) &#123; printf(&quot;错误ERROR!&quot;); return 1; &#125; if (flag == 1) &#123; syscall(_SYSCALL_dhsyscall_, pid, 1, nicevalue, &amp;cur_prio, &amp;cur_nice); printf(&quot;原来的 priority: [%d], nice [%d]\\n&quot;, prev_prio, prev_nice); printf(&quot;现在的 priority: [%d], nice [%d]\\n&quot;, cur_prio, cur_nice); &#125; else if (flag == 0) &#123; printf(&quot;现在的 priority: [%d], nice [%d]\\n&quot;, prev_prio, prev_nice); &#125; return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"B站计网课程学习总结（一）","slug":"B站计网课程学习总结","date":"2020-11-25T10:51:33.567Z","updated":"2020-11-25T10:59:52.313Z","comments":true,"path":"2020-11-25-B站计网课程学习总结.html","link":"","permalink":"http://immnaruto.github.io/2020-11-25-B%E7%AB%99%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html","excerpt":"B站计网课程学习总结（一）前言因HDU老师讲课学不进去（疯狂划水），在学习网站B站上找到了王道的计网视频，觉得讲的很不错，故根据此课程来总结学习大纲（快期末了QAQ）","text":"B站计网课程学习总结（一）前言因HDU老师讲课学不进去（疯狂划水），在学习网站B站上找到了王道的计网视频，觉得讲的很不错，故根据此课程来总结学习大纲（快期末了QAQ） 1.第一章综述","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://immnaruto.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"ROS小车学习记录","slug":"ROS小车学习记录","date":"2020-11-24T14:40:16.584Z","updated":"2020-11-25T10:51:05.222Z","comments":true,"path":"2020-11-24-ROS小车学习记录.html","link":"","permalink":"http://immnaruto.github.io/2020-11-24-ROS%E5%B0%8F%E8%BD%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html","excerpt":"ROS小车学习记录一、配置与连接1.配置VMware虚拟机及ROS Kinetic 16.04.2a）安装好虚拟机及镜像，虚拟机初始设置为2核4G，设置为4核4G","text":"ROS小车学习记录一、配置与连接1.配置VMware虚拟机及ROS Kinetic 16.04.2a）安装好虚拟机及镜像，虚拟机初始设置为2核4G，设置为4核4G b）设置虚拟机网络模式为桥接模式，用Windows的无线网卡桥接 c）确认Windows IP地址和虚拟机 IP地址（应在同一网段下） 以本机为例： windows IP：192.108.1.103 ROS IP：192.108.1.108 2.树莓派Ubuntu Mate系统安装注：若树莓派上自带有SD卡即Ubuntu Mate已默认安装，若没有需安装。 a）需要的软件和功能： Panasonic_SDFormatter ubuntu-mate-16.04 Win32DiskImager b）操作过程： 1、Panasonic_SDFormatter格式化TF卡； 2、Win32DiskImager工具将ubuntu-mate-16.04的img文件烧写到TF卡中，然后插入到开发板中。 3、开发板连接鼠标和键盘、HDMI连接显示器、然后通电。通电以后需要对系统进行一些设置才能正常使用系统，具体操作可以根据向导来完成。 4、连接WIFI。必须保证PC，虚拟机和小车处于同一网络下，然后连接WIFI，查看连接配置，通过路由器配置界面得到小车端的IP。 小车端IP：192.168.1.109 5、通过PC端的虚拟机测试是否能PING通小车端。 c）存在问题与简便解决 使用上述操作过程可能会存在一些问题，如无法进入系统（彩虹屏）及无法连接WIFI等，可以通过修改系统启动boot项及更换系统网络配置文件解决，但较为繁琐，之后学长提供了一种简便方法：直接恢复已配置好的镜像即可。 使用工具：usb image tool 将上述第二步改为恢复镜像即可。 3.使用ROS Ubuntu连接小车端a）ping通小车端 b）路由器管理界面找到小车端IP地址 假设 虚拟机IP地址 192.168.1.108 小车端 IP地址 192.168.1.109 c）虚拟机中 打开终端，输入指令 1gedit ~&#x2F;.bashrc 找到文档最下面，输入（修改）两行 12export ROS_MASTER_URI&#x3D;http:&#x2F;&#x2F;192.168.0.109:11311 #指定 XRobot 为 ROS Masterexport ROS_HOSTNAME&#x3D;192.168.0.108 #这里是虚拟机 IP 保存退出。 d）虚拟机端：使用ssh指令连接 1ssh nodes@192.168.0.109 连接到小车端，若连接成功，终端会变为nodes@xrobot： e）小车端验证是否能ping通虚拟机端 f）ping通后，输入指令 1nano ~&#x2F;.bashrc 最下面修改两行：（IP地址是小车端） 12export ROS_MASTER_URI&#x3D;http:&#x2F;&#x2F;192.168.0.109:11311export ROS_HOSTNAME&#x3D;192.168.0.109 保存即可。 4.配置ssh免密登录a）首先,在本地计算机生成公钥和私钥。打开终端,执行命令: 1ssh-keygen 一直按回车键选择默认选项,会在~/.ssh 目录下生成 id_rsa 和 id_rsa.pub 两个文件。然后将 id_rsa.pub 文件复制到远程计算机: 1scp ~&#x2F;.ssh&#x2F;id_rsa.pub username@ip_address:&#x2F;home&#x2F;username 本机中，所用命令为scp ~/.ssh/id_rsa.pub &#110;&#x6f;&#100;&#101;&#x73;&#x40;&#49;&#57;&#x32;&#x2e;&#49;&#x36;&#56;&#x2e;&#49;&#46;&#49;&#x30;&#x39;:/home/nodes b）将公钥文件 id_rsa.pub 拷贝到远程计算机后,SSH 登录到远程计算机: 1ssh username@ip_address 其中 username 为远程计算机用户名,ip_address 为远程计算机的 IP 地址。 c）登录后,将id_rsa.pub 的文件内容追加写入到远程计算机的~/.ssh/authorized_keys 文件中,并修改 authorized_keys 文件的权限: 12$ cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys$ chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys 配置完成后,再登录远程计算机就无需输入密码。 d）接下来,即可配置 RoboWare Studio的远程调试参数进行远程调试修改远程计算机/etc/profile首先,登录远程计算机: 1$ ssh username@ip_address 登录后,切换到 root 用户权限,将 ROS 环境变量信息写入到/etc/profile 文件中: 12$ sudo su$ echo &quot;source &#x2F;opt&#x2F;ros&#x2F;indigo&#x2F;setup.bash&quot; &gt;&gt; &#x2F;etc&#x2F;profile 接下来在roboware上配置远程主控信息 步骤：IP，用户名（nodes），一直敲回车就可以了。 二、调试及运行1.调试","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"ROS小车","slug":"ROS小车","permalink":"http://immnaruto.github.io/tags/ROS%E5%B0%8F%E8%BD%A6/"}]},{"title":"HDU操作系统实验二","slug":"HDU操作系统实验二","date":"2020-11-24T11:43:47.819Z","updated":"2020-11-26T02:50:00.479Z","comments":true,"path":"2020-11-24-HDU操作系统实验二.html","link":"","permalink":"http://immnaruto.github.io/2020-11-24-HDU%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C.html","excerpt":"HDU操作系统实验二一、实验要求1.设计一个模块，要求列出系统中所有内核线程的程序名、PID、进程状态、进程优先级、父进程的PID。 2.设计一个带参数的模块，其参数为某个进程的PID号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID号及进程状态。 3.进一步分析相关内核函数。","text":"HDU操作系统实验二一、实验要求1.设计一个模块，要求列出系统中所有内核线程的程序名、PID、进程状态、进程优先级、父进程的PID。 2.设计一个带参数的模块，其参数为某个进程的PID号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID号及进程状态。 3.进一步分析相关内核函数。 二、实验思路1.第一个的整体思路是遍历各线程，通过用户地址标识符将内核线程和用户线程分开，通过pid进程描述符输出即可。 2.第二个实验要求需要在加载模块时提供对应pid传入参数，父进程和子进程直接遍历即可，兄弟进程稍微复杂些，需返回父进程的子进程的链表头字段，然后逐个遍历（排除传入pid的进程）。 三、实验步骤1.实验一要求较为简单，在内核目录下创建module1文件夹，新建module1.c和Makefile module1.c 12345678910111213141516171819202122232425262728293031#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/sched/signal.h&gt;// 初始化函数static int hello_init(void)&#123; struct task_struct *p; printk(KERN_ALERT&quot;\\t\\t名称\\t进程号\\t状态\\t优先级\\t&quot;); for_each_process(p) &#123; if(p-&gt;mm == NULL)&#123; //内核线程的mm成员为空 printk(KERN_ALERT&quot;%16s\\t%d\\t%ld\\t%d\\n&quot;,p-&gt;comm,p-&gt;pid, p-&gt;state,p-&gt;normal_prio); &#125; &#125; return 0;&#125;// 清理函数static void hello_exit(void)&#123; printk(KERN_ALERT&quot;goodbye!\\n&quot;);&#125;// 函数注册module_init(hello_init); module_exit(hello_exit); // 模块许可申明MODULE_LICENSE(&quot;GPL&quot;); Makefile 123456789obj-m:=module1.oKDIR:=/lib/modules/$(shell uname -r)/buildPWD:=$(shell pwd)default: $(MAKE) -C $(KDIR) M=$(PWD) modulesclean: $(MAKE) -C $(KDIR) M=$(PWD) clean 输入以下命令编译并加载模块，结果如下图所示。 1234make #编译sudo insmod module3.ko #加载模块lsmod #查看已加载的模块dmesg #输出日志信息 2.实验二与实验一类似，同样编写module2.c和Makefile module2.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/kernel.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/moduleparam.h&gt;static pid_t pid=1;module_param(pid,int,0644);static int hello_init(void)&#123; struct task_struct *p; struct list_head *pp; struct task_struct *psibling; // 当前进程的 PID p = pid_task(find_vpid(pid), PIDTYPE_PID); printk(&quot;me: %d %s\\n&quot;, p-&gt;pid, p-&gt;comm); // 父进程 if(p-&gt;parent == NULL) &#123; printk(&quot;No Parent\\n&quot;); &#125; else &#123; printk(&quot;Parent: %d %s\\n&quot;, p-&gt;parent-&gt;pid, p-&gt;parent-&gt;comm); &#125; // 兄弟进程 list_for_each(pp, &amp;p-&gt;parent-&gt;children) &#123; psibling = list_entry(pp, struct task_struct, sibling); printk(&quot;sibling %d %s \\n&quot;, psibling-&gt;pid, psibling-&gt;comm); &#125; // 子进程 list_for_each(pp, &amp;p-&gt;children) &#123; psibling = list_entry(pp, struct task_struct, sibling); if (psibling-&gt;pid == pid) continue; printk(&quot;children %d %s \\n&quot;, psibling-&gt;pid, psibling-&gt;comm); &#125; return 0;&#125;static void hello_exit(void)&#123; printk(KERN_ALERT&quot;goodbye!\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;); Makefile 123456789obj-m:=module2.oKDIR:=/lib/modules/$(shell uname -r)/buildPWD:=$(shell pwd)default: $(MAKE) -C $(KDIR) M=$(PWD) modulesclean: $(MAKE) -C $(KDIR) M=$(PWD) clean 同样地，输入以下命令编译并加载模块，结果如下图所示。 12345make #编译pstree -p #选择进程pidsudo insmod module2.ko pid&#x3D;1418 #加载模块lsmod #查看已加载的模块dmesg #输出日志信息 四、实验反思与总结1.判断内核线程：通过进程用户地址空间描述符来判断，内核线程的mm字段为NULL。 1struct mm_struct *mm #进程用户地址空间描述符 2.进程状态： **R(TASK_RUNNING)**，可执行状态。 只有在该状态的进程才可能在CPU上运行，同一时刻可能有多个进程处于可执行状态。 **S(TASK_INTERRUPTIBLE)**，可中断的睡眠状态。 处于这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量），而被挂起。当这些事件发生时，对应的等待队列中的一个或多个进程将被唤醒。一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态。 **D(TASK_UNINTERRUPTIBLE)**，不可中断的睡眠状态。 与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的是进程不响应异步信号，无法用kill命令关闭处于TASK_UNINTERRUPTIBLE状态的进程。 **T(TASK_STOPPED or TASK_TRACED)**，暂停状态或跟踪状态。 向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。当进程正在被跟踪时，它处于TASK_TRACED状态。 **Z(TASK_DEAD - EXIT_ZOMBIE)**，退出状态。 进程在退出的过程中，处于TASK_DEAD状态，如果它的父进程没有收到SIGCHLD信号，故未调用wait（如wait4、waitid）处理函数等待子进程结束，又没有显式忽略该信号，它就一直保持EXIT_ZOMBIE状态。只要父进程不退出，这个EXIT_ZOMBIE状态的子进程就一直存在。 **X(TASK_DEAD - EXIT_DEAD)**，退出状态，进程即将被销毁。 EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。 3.优先级调度a）调度算法 ​ linux内核目前实现了6中调度策略(即调度算法), 用于对不同类型的进程进行调度, 或者支持某些特殊的功能，其中SCHED_NORMAL和SCHED_BATCH调度普通的非实时进程, SCHED_FIFO和SCHED_RR和SCHED_DEADLINE则采用不同的调度策略调度实时进程, SCHED_IDLE则在系统空闲时调用idle进程. 字段 描述 SCHED_NORMAL （也叫SCHED_OTHER）用于普通进程，通过CFS调度器实现。SCHED_BATCH用于非交互的处理器消耗型进程。SCHED_IDLE是在系统负载很低时使用 SCHED_BATCH SCHED_NORMAL普通进程策略的分化版本。采用分时策略，根据动态优先级(可用nice()API设置），分配CPU运算资源。注意：这类进程比上述两类实时进程优先级低，换言之，在有实时进程存在时，实时进程优先调度。但针对吞吐量优化, 除了不能抢占外与常规任务一样，允许任务运行更长时间，更好地使用高速缓存，适合于成批处理的工作 SCHED_IDLE 优先级最低，在系统空闲时才跑这类进程(如利用闲散计算机资源跑地外文明搜索，蛋白质结构分析等任务，是此调度策略的适用者） SCHED_FIFO 先入先出调度算法（实时调度策略），相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务 SCHED_RR 轮流调度算法（实时调度策略），后者提供 Roound-Robin 语义，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。不同要求的实时任务可以根据需要用sched_setscheduler() API设置策略 SCHED_DEADLINE 新支持的实时进程调度策略，针对突发型计算，且对延迟和完成时间高度敏感的任务适用。基于Earliest Deadline First (EDF) 调度算法 b）优先级定义 1234567#define MAX_NICE 19#define MIN_NICE -20#define NICE_WIDTH (MAX_NICE - MIN_NICE + 1)#define MAX_USER_RT_PRIO 100#define MAX_RT_PRIO MAX_USER_RT_PRIO#define MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH)#define DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2) ​ 程序的优先级范围为[0,139]，有效的实时优先级（RT priority）范围为[0,99]，SCHED_NORMAL和SCHED_BATCH这两个非实时任务的优先级为[100,139]。[100,139]这个区间的优先级又称为**静态优先级(static priority)**。之所以称为静态优先级是因为它不会随着时间而改变，内核不会修改它，只能通过系统调用nice去修改。静态优先级用进程描述符中的static_prio表示。优先级的值越低，表示具有更高的优先级，0的优先级最高。 优先级范围 描述 0——99 实时进程（RT priority）优先级范围 100——139 非实时进程（非实时调度器SCHED_NORMAL和SCHED_BATCH）优先级范围 ​ MAX_USER_RT_PRIO的值（默认为100）让用户态的优先级范围区别于实时优先级的最大值（99）。这样设计的好处是任何内核态线程的优先级都大于用户态的任务线程。注意：最大实时优先级（MAX_RT_PRIO）不得小于用户态优先级（MAX_USER_RT_PRIO）。 ​ 用户的nice值[-20,19]对应于静态优先级的[100,139]，也就是说，nice值越小，优先级越低。用户的nice值与优先级的转化关系为 12#define NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO)#define PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO) 可用下图来总结所对应的关系： 4.进程的task_struct结构及家族关系a）管理进程最重要的数据结构即为进程控制块（PCB），为task_struct类型的结构体，主要的相关标识符字段有： 12pid_t pid #进程标识符PIDpid_t tgid #线程组领头线程PID b）家族关系 除0号进程外，所有进程都是PID为1的init进程的后代。task_struct结构中描述家族关系主要字段有： 1234struct task_struct *real_parent #指向创建该进程的父进程struct task_struct *parent #指向该进程的当前父进程（一般与上面相同）struct list_head children #指向该进程子进程链表头部struct list_head sibling #指向兄弟进程链表中的下一个或前一个节点 由sibling字段链接成为父进程的children链表。 5.链表遍历进程原理1.list_for_each()和list_entry() 宏定义： 12#define list_for_each(pos, head) \\ for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next) 此定义只找到了list_head域的位置pos，通过list_entry()获得结构体起点地址。 12#define list_entry(ptr, type, member) \\ container_of(ptr, type, member) 其中ptr的值减去type结构体中member的偏移量，即可得出首地址。 2.for_each_process(p)和list_for_each_entry() 1234#define list_for_each_entry(pos, head, member) \\ for (pos &#x3D; list_first_entry(head, typeof(*pos), member); \\ &amp;pos-&gt;member !&#x3D; (head); \\ pos &#x3D; list_next_entry(pos, member)) 12#define for_each_process(p) for(p&#x3D;&amp;init_task; p&#x3D;next_task(p)!&#x3D;&amp;init_task) 可见，均为循环遍历链表算法。","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"超星跨文化交际题库查漏补缺","slug":"跨文化交际","date":"2020-11-18T02:50:53.495Z","updated":"2020-11-21T09:16:53.548Z","comments":true,"path":"2020-11-18-跨文化交际.html","link":"","permalink":"http://immnaruto.github.io/2020-11-18-%E8%B7%A8%E6%96%87%E5%8C%96%E4%BA%A4%E9%99%85.html","excerpt":"1 语境这一概念最早由波兰人类学家B.Malinowski在1923年提出来的。他将语境分为 情景 文化 语言交际分为口语交际和书面语交际。 下列属于高语境语言交际特点的是表情、空间、沉默 “西方乒乓球式”双向交际的表现是互动频繁 当面争执","text":"1 语境这一概念最早由波兰人类学家B.Malinowski在1923年提出来的。他将语境分为 情景 文化 语言交际分为口语交际和书面语交际。 下列属于高语境语言交际特点的是表情、空间、沉默 “西方乒乓球式”双向交际的表现是互动频繁 当面争执 2 在交际过程中不使用口头或文字形式进行信息传递的沟通方式即为非语言交际。 语言交际在人们面对面交际过程中仅占35%左右,其余65%主要是靠非语言交际手段来完成的。 在握手时，应由 女子; 主人; 年长者; 身份职位高者 先伸手。 文字 不属于非语言交际中的文化符号 韩国的公务聚会中应该首先给 职务最高者 敬酒 美国人的合适的社交距离 4-12英尺 3 在美国，百合象征着die 在美国猫头鹰代表着吉祥 X 表示“强壮”意思的英文表达是 as strong as a tiger 英文Don’t lie there. 双关 从传统上讲中国的春节是正月初一开始，一直延续到正月十五。 X 圣诞季节一般是从感恩节过后的“黑色星期五”开始，一直延续的第二年的元月15日 X 4西方人在旅游的时候，喜欢用相机去看，去记录。 X 习语的三个特征是语言整体性、结构凝固性和不可替代性。 慷慨准则是指 多称赞别人 在美国考驾照，倒车的时候要注意看倒视镜。 X 在英语里，“熊”意为聪明、伶俐。 5鸠摩罗什把佛教从西方引入中国，将大量经书翻译成汉语，为佛教在中国的传播做出了巨大的贡献。他与（ ）和玄奘并称为中国佛教四大译经家。 A. 不空 B. 鉴真 C. 法显 D. 真谛 AD 下面哪些属于中国八大建筑流派？ ABDE A. 江南民居 B. 川西民居 C. 蒙古包 D. 北京四合院 E. 书院建筑 中国古典建筑风格可以用以下哪12个字概括？ BCD A. 金碧辉煌 B. 雕梁画柱 C. 飞檐斗拱 D. 亭台楼阁 下面哪些建筑属于罗马式建筑？ A. 德国科隆大教堂 B. 伦敦圣保罗大教堂 C. 梵蒂冈圣保罗大教堂 D. 意大利米兰大教堂 E. 巴黎圣母院大教堂 正确答案B,C","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"网课","slug":"网课","permalink":"http://immnaruto.github.io/tags/%E7%BD%91%E8%AF%BE/"}]},{"title":"我的博客","slug":"myblog","date":"2020-11-17T11:56:12.532Z","updated":"2020-11-23T14:27:49.829Z","comments":true,"path":"2020-11-17-myblog.html","link":"","permalink":"http://immnaruto.github.io/2020-11-17-myblog.html","excerpt":"","text":"写在开始 一点介绍你好，这里是Hai的BLOG，本人目前是计算机科学与技术专业的一枚大三弱鸡，杭电在读，打算考研。 搭建博客的初衷其实只是脑子一热，在查阅资料的时候看到了杭电学长搭建的博客非常nice，想着自己也可以尝试记录一些自己遇到的问题和经验分享，当然最主要的是给自己提供一个平台用来记录所学内容（老懒狗了），当然也会有一些生活点滴的分享（程序员嘛，不能太死宅），如果不嫌麻烦，就关注一下啦~:laughing: 从个人角度来说，想要快速进步最好的办法是实践，另外可以多写写博客看看博客（CSDN老选手了），记录自己遇到的种种问题，可以让我有动力继续学下去（虽然我觉得我是挺喜欢这个专业的，虽然遇到了很多困难和发现他没有我想的那么简单），另外在遇到各种困难查阅资料的时候，我发现很多基础的东西很难找到相关的教程，很难学懂，所以成长到正常实力其实还是要有很长很长很痛苦的路要走的，而如果我把其中的过程记录下来，或许也可以为和我一样情况，没有基础又找不到合适资料的人提供方便。 希望有朝一日，自己能成长起来，能做到自己想做的事情，看到曾经弱鸡的自己，露出一副欣慰的笑容哈哈哈哈，也希望能够和大家一同进步！ 暂时打算目前可能会在ROS机器人和Linux操作系统方向进行主要的学习。 PS：一些闲言碎语尽量不要三分钟热度…把自己所学的和所想的做好分享即可。","categories":[],"tags":[]}],"categories":[{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://immnaruto.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"ROS小车","slug":"ROS小车","permalink":"http://immnaruto.github.io/tags/ROS%E5%B0%8F%E8%BD%A6/"},{"name":"网课","slug":"网课","permalink":"http://immnaruto.github.io/tags/%E7%BD%91%E8%AF%BE/"}]}