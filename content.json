{"meta":{"title":"Hai的BLOG","subtitle":"ImmNaruto","description":"个人博客","author":"DH","url":"http://immnaruto.github.io","root":"/"},"pages":[{"title":"关于","date":"2020-11-21T08:43:50.000Z","updated":"2020-11-27T08:01:51.016Z","comments":false,"path":"about/index.html","permalink":"http://immnaruto.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-11-21T07:17:13.000Z","updated":"2020-11-21T09:26:00.663Z","comments":false,"path":"categories/index.html","permalink":"http://immnaruto.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-21T07:19:42.000Z","updated":"2020-11-21T09:25:48.898Z","comments":false,"path":"tags/index.html","permalink":"http://immnaruto.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HDU操作系统实验三","slug":"HDU操作系统实验三","date":"2020-12-15T01:53:57.155Z","updated":"2020-12-17T02:38:20.679Z","comments":true,"path":"2020-12-15-HDU操作系统实验三.html","link":"","permalink":"http://immnaruto.github.io/2020-12-15-HDU%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89.html","excerpt":"HDU操作系统实验三一、实验要求 实验名：Linux进程管理","text":"HDU操作系统实验三一、实验要求 实验名：Linux进程管理 实验要求：1）实现一个模拟的shell ​ 编写三个不同的程序cmd1.c、cmd2.c及cmd3.c，每个程序的功能自定，分别编译成可执行文件cmd1、cmd2、cmd3.然后再编写一个程序，模拟shell程序的功能：能根据用户输入的字符串（表示相应的命令名），为相应的命令创建子进程并让他去执行相应的程序，而父进程则等待子进程结束，然后再接收下一条命令。如果接收到的命令为exit，则父进程结束，退出模拟shell；如果接收到的命令是无效命令，则显示“Command not found”，继续等待输入下一条命令。 2）实现一个管道通信程序 ​ 由父进程创建一个管道，然后再创建三个子进程，并由这三个子进程利用管道与父进程之间进行通信：子进程发送信息，父进程等三个子进程全部发完消息后再接收信息。通信的具体内容可根据自己的需要随意设计，要求能试验阻塞型读写过程中的各种情况，测试管道的默认大小，并且要求利用 Posix 信号量机制实现进程间对管道的互斥访问。运行程序，观察各种情况下，进程实际读写的字节数以及进程阻塞唤醒的情况。 ​ 3）利用Linux消息队列通信机制实现两个线程间的通信 编写程序创建三个线程：sender1线程、sender2线程和receiver线程，三个线程的功能描述如下： ①sender1线程：运行函数sender1()，它创建一个消息队列，然后等待用户通过终端输入一串字符，并将这串字符通过消息队列发给receiver线程;可循环发送多个消息，直到用户输入“exit”为止，表示它不再发送消息，最后向receiver线程发送消息“end1”，并且等待receiver的应答（老师告知可以省略这步，所以代码没有体现，sender2同），等到应答消息后，将接收到的应答信息显示在终端屏幕上，结束线程的运行。 ​ ②sender2线程：运行函数sender2()，共享sender1创建的消息队列，等待用户通过终端输入一串字符，并将这串字符通过消息队列发送给receiver线程；可循环发送多个消息，直到用户输入“exit”为止，表示它不再发送消息，最后向receiver线程发送消息“end2”，并且等待receiver的应答，等到应答消息后，将接收到的应答信息显示在终端屏幕上，结束线程的运行。 ​ ③receiver线程：运行函数receive()，它通过消息队列接收来自sender1和sender2两个线程的消息，将消息显示在终端屏幕上，当收到内容为“end1”的消息时，就向sender1发送一个应答消息“over1”；当收到内容为“end2”的消息时，就向sender2发送一个应答消息“over2”；消息接受完成后删除消息队列，结束线程的运行。选择合适的信号量机制实现三个线程之间的同步和互斥 ​ 4）利用Linux共享内存通信机制实现两个进程间的通信 二、实验思路1.第一个的整体思路是遍历各线程，通过用户地址标识符将内核线程和用户线程分开，通过pid进程描述符输出即可。 2.第二个实验要求需要在加载模块时提供对应pid传入参数，父进程和子进程直接遍历即可，兄弟进程稍微复杂些，需返回父进程的子进程的链表头字段，然后逐个遍历（排除传入pid的进程）。","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"生活随笔","slug":"生活随笔","date":"2020-11-29T15:35:18.212Z","updated":"2020-11-30T06:51:08.513Z","comments":true,"path":"2020-11-29-生活随笔.html","link":"","permalink":"http://immnaruto.github.io/2020-11-29-%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94.html","excerpt":"1 《怀旧》我好像是个怀旧的人。","text":"1 《怀旧》我好像是个怀旧的人。 高中三年想着初中，大学三年想着高中，听歌还全是老歌，以至于现在天天循环从初中开始听了七年的歌（写随笔的时候听的是许嵩的《庐州月》)…说实话，我一点都没有变，只是在努力地适应着生活。 而我身边的人不这样。 今天晚上，一个高中的好朋友给我分享了一个链接，标题是：国家奖学金获得者XXX（她本人），一路前行，嘴上说着祝贺，心里略微有了一点苦涩。是啊，相比起其他人的大学，我真的太普通不过了。说着是在计算机专业学习，但是内心对什么都很排斥，想着在自己的小天地，碌碌无为，好吃懒做，在这个高手如云的专业，甚至都排不上号，看着别人一步步变得更好，自己剩下的只有无力。 之前看到老番茄的毕业视频，其中有一幕是登台演讲的时候，灯光都聚集在他的身上，弹幕都在说他在发光，也许我也曾渴望自己来到大学是这个模样，但三年过去了，一点没变。 一时不知道说什么下去了，祝大家在自己的世界里，都熠熠发光吧。 2 《熬夜冠军》凌晨两点半，某男生宿舍。 睡不着的我翻来覆去，刷着视频，一会儿上个厕所，一会坐起来喝水…熬夜人常态。 本来以为是个平常的一天，但今天不一样。 两点半，坐起身，准备上厕所时候，临铺突然支起身子来，好像在看我。我试探性的叫了一声“凡凡”，因为这种事不是一次两次了，而且刚刚还说着梦话。没想到，得到了应答：睡不着。 我一阵偷笑，拍了拍他，说早点睡，下了床。唯一的下铺今天也灯火通明（没睡）。 我也拍了拍他，说睡吧。 上完厕所爬上床，感觉到了一丝欣慰。因为，我不再是孤军奋战了（doge） 于是今天四点半才睡着… 下次一定不熬夜了！！！！","categories":[{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"HDU操作系统实验一","slug":"HDU操作系统实验一","date":"2020-11-27T06:16:49.146Z","updated":"2020-11-29T15:28:26.101Z","comments":true,"path":"2020-11-27-HDU操作系统实验一.html","link":"","permalink":"http://immnaruto.github.io/2020-11-27-HDU%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80.html","excerpt":"HDU操作系统实验一一、实验要求 添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级。建议调用原型是int mysetnice(pid_t pid, int flag, int nicevalue, void_user* prio, void_user* nice)参数含义：","text":"HDU操作系统实验一一、实验要求 添加一个系统调用，实现对指定进程的nice值的修改或读取功能，并返回进程最新的nice值及优先级。建议调用原型是int mysetnice(pid_t pid, int flag, int nicevalue, void_user* prio, void_user* nice)参数含义： pid：进程IDflag：若为0，则表示读取nice的值；若为1，则表示修改nice的值。nicevalue：为指定的进程设置新的nice。prio，nice：指向进程的优先级和nice值。返回值：系统调用成功时返回0；失败时返回错误码EFAULT。 写一个简单的应用程序测试（1）中添加的系统调用。 若系统调用了Linux的内核函数，要求深入阅读相关的源码。 二、实验思路 个人理解为通过修改系统调用表实现系统调用（即调用系统自带函数），例如c语言的头文件。 通过将调用例程写入内核并编译内核，完成所述要求。 三、实验步骤 前期准备工作 虚拟机上需要安装ubuntu，本人安装了Ubuntu 16.04.2，配置要求有两点： 内存分配40G以上 CPU分配4核（双核双线程） 安装好后，还需要去官网下载linux内核源码，本人下载的版本是linux-4.16.3.tar.xz，传到虚拟机中，解压出来即可。 分配系统调用号，修改系统调用表 查看系统调用表(linux-4.16.3/arch/x86/entry/syscalls/syscall_64.tbl) 在这里我们需要选择一个未使用过的系统调用号进行分配，当前系统使用到332号，所以我们选择新添加的系统调用号为333号。 声明系统调用服务例程 Linux系统调用服务例程的原型申明在文件 (./include/linux/syscalls.h) 中，我们可以添加如图所示的内容 每个系统调用都对应一个内核服务例程来实现该系统调用的具体功能，其命名格式都是以“sys_”开头。其中“asmlinkage”是一个必须的限定词，用于通知编译器仅从堆栈中提取该函数的参数，而不是从寄存器中，因为在执行服务例程之前系统已经将通过寄存器传递过来的参数值压入内核堆栈了。 实现系统调用服务 下面为新调用的 mysetnice 编写服务例程 sys_dhsyscall， 通常添加在 sys.c 文件中，其路径为 (./kernel/sys.c )。 1234567891011121314151617181920212223SYSCALL_DEFINE5(dhsyscall,pid_t,pid,int,flag,int,nicevalue,void __user*,prio,void __user*,nice)&#123; struct pid * kpid; struct task_struct * pcb; kpid = find_get_pid(pid);/* 返回pid */ pcb = pid_task(kpid, PIDTYPE_PID);/* 返回task_struct */ int now_nice,now_prio; if(flag == 1) &#123; set_user_nice(pcb, nicevalue);/* 修改进程nice值 */ &#125; else if(flag != 0) &#123; return EFAULT; &#125; now_prio = task_prio(pcb);/*返回进程当前prio值*/ now_nice = task_nice(pcb);/*重新取得进程nice值*/ copy_to_user(nice,&amp; now_nice,sizeof(now_nice));/*将nice值拷贝到用户空间*/ copy_to_user(prio,&amp; now_prio,sizeof(now_prio));/*将prio值拷贝到用户空间*/ return 0;&#125; 这是一个简单的实现读取进程 nice 值和修改进行 nice 值的服务。当参数 flag 为 0 的时候读取 nice 值，并将数据从内核空间拷贝到用户空间。当 flag 为 1 的时候修改 nice 值为 nicevalue 的值。 在新版本的内核中，引入了宏“SYSCALL_DEFINEN(sname)”对服务例程原型进行了封装，其中的“N”是该系统调用所需要参数的个数， 在这里我们使用了 5 个参数所以是 DEFINE5。 编译内核 清除残留的.config 和.o 文件 编译出错需要重新编译或不是第一次编译，都需要清除残留的.config 和.o 文件，方法是进入Linux内核所在的子目录， 执行以下命令： 1# make mrproper 这里可能会提醒安装 ncurses 包，在 ubuntu 中 ncurses 库的名字是 libncurses5-dev，安装命令是： 1# apt-get install libncurses5-dev 配置内核 执行命令 1# make menuconfig 运行该命令过程中，可能会报错提示缺少一个套件 ncurses devel，那么你需要手动对其进行安装，安装方法同上安装 ncurses 包的过程。 在执行 make menuconfig 命令的时候会出现一个配置对话框，我们一般采用默认值：选择保存配置信息，然后选择退出对话框。 编译内核，生成启动映像文件 内核配置完后，编译内核，生成启动映像文件 bzlmage ，位于 (./arch/x86_64/boot/bzlmage) 中，执行命令： 1# make 这里也许会提示没有安装 openssl，安装的方法如下： 1# apt-get install libssl-dev 内核编译时间可能较长，视硬件配置而定，一般情况为2小时左右 编译模块 1# make modules 安装模块/内核 12# make modules_install# make install 配置 grub 引导程序 1# update-grub2 重启系统 1# reboot 重启系统后，可以通过终端来查看新内核的版本。输入如下指令 1uname -r 观察显示的内核版本是否与编译的内核版本一致。 编写用户态测试程序 测试程序如下： test.c 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;unistd.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;stdio.h&gt;#define _SYSCALL_dhsyscall_ 333#define EFALUT 14 /*这里linux中错误码EFAULT的值为14*/int main()&#123; int pid, flag, nicevalue; int prev_prio, prev_nice, cur_prio, cur_nice; int result; printf(&quot;请输入PID flag nicevalue: &quot;); scanf(&quot;%d%d%d&quot;, &amp;pid, &amp;flag, &amp;nicevalue); result = syscall(_SYSCALL_dhsyscall_, pid, 0, nicevalue, &amp;prev_prio, &amp;prev_nice); if (result == EFALUT) &#123; printf(&quot;错误ERROR!&quot;); return 1; &#125; if (flag == 1) &#123; syscall(_SYSCALL_dhsyscall_, pid, 1, nicevalue, &amp;cur_prio, &amp;cur_nice); printf(&quot;原来的 priority: [%d], nice [%d]\\n&quot;, prev_prio, prev_nice); printf(&quot;现在的 priority: [%d], nice [%d]\\n&quot;, cur_prio, cur_nice); &#125; else if (flag == 0) &#123; printf(&quot;现在的 priority: [%d], nice [%d]\\n&quot;, prev_prio, prev_nice); &#125; return 0;&#125;","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"B站计网课程学习总结（一）","slug":"B站计网课程学习总结","date":"2020-11-25T10:51:33.567Z","updated":"2020-11-25T10:59:52.313Z","comments":true,"path":"2020-11-25-B站计网课程学习总结.html","link":"","permalink":"http://immnaruto.github.io/2020-11-25-B%E7%AB%99%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html","excerpt":"B站计网课程学习总结（一）前言因HDU老师讲课学不进去（疯狂划水），在学习网站B站上找到了王道的计网视频，觉得讲的很不错，故根据此课程来总结学习大纲（快期末了QAQ）","text":"B站计网课程学习总结（一）前言因HDU老师讲课学不进去（疯狂划水），在学习网站B站上找到了王道的计网视频，觉得讲的很不错，故根据此课程来总结学习大纲（快期末了QAQ） 1.第一章综述","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://immnaruto.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"ROS小车学习记录","slug":"ROS小车学习记录","date":"2020-11-24T14:40:16.584Z","updated":"2020-12-18T03:05:32.497Z","comments":true,"path":"2020-11-24-ROS小车学习记录.html","link":"","permalink":"http://immnaruto.github.io/2020-11-24-ROS%E5%B0%8F%E8%BD%A6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.html","excerpt":"ROS小车学习记录一、配置与连接1.配置VMware虚拟机及ROS Kinetic 16.04.2a）安装好虚拟机及镜像，虚拟机初始设置为2核4G，设置为4核4G","text":"ROS小车学习记录一、配置与连接1.配置VMware虚拟机及ROS Kinetic 16.04.2a）安装好虚拟机及镜像，虚拟机初始设置为2核4G，设置为4核4G b）设置虚拟机网络模式为桥接模式，用Windows的无线网卡桥接 c）确认Windows IP地址和虚拟机 IP地址（应在同一网段下） 以本机为例： windows IP：192.108.1.103 ROS IP：192.108.1.108 2.树莓派Ubuntu Mate系统安装注：若树莓派上自带有SD卡即Ubuntu Mate已默认安装，若没有需安装。 a）需要的软件和功能： Panasonic_SDFormatter ubuntu-mate-16.04 Win32DiskImager b）操作过程： 1、Panasonic_SDFormatter格式化TF卡； 2、Win32DiskImager工具将ubuntu-mate-16.04的img文件烧写到TF卡中，然后插入到开发板中。 3、开发板连接鼠标和键盘、HDMI连接显示器、然后通电。通电以后需要对系统进行一些设置才能正常使用系统，具体操作可以根据向导来完成。 4、连接WIFI。必须保证PC，虚拟机和小车处于同一网络下，然后连接WIFI，查看连接配置，通过路由器配置界面得到小车端的IP。 小车端IP：192.168.1.109 5、通过PC端的虚拟机测试是否能PING通小车端。 c）存在问题与简便解决 使用上述操作过程可能会存在一些问题，如无法进入系统（彩虹屏）及无法连接WIFI等，可以通过修改系统启动boot项及更换系统网络配置文件解决，但较为繁琐，之后学长提供了一种简便方法：直接恢复已配置好的镜像即可。 使用工具：usb image tool 将上述第二步改为恢复镜像即可。 3.使用ROS Ubuntu连接小车端a）ping通小车端 b）路由器管理界面找到小车端IP地址 假设 虚拟机IP地址 192.168.1.108 小车端 IP地址 192.168.1.109 c）虚拟机中 打开终端，输入指令 1gedit ~&#x2F;.bashrc 找到文档最下面，输入（修改）两行 12export ROS_MASTER_URI&#x3D;http:&#x2F;&#x2F;192.168.0.109:11311 #指定 XRobot 为 ROS Masterexport ROS_HOSTNAME&#x3D;192.168.0.108 #这里是虚拟机 IP 保存退出。 d）虚拟机端：使用ssh指令连接 1ssh nodes@192.168.0.109 连接到小车端，若连接成功，终端会变为nodes@xrobot： e）小车端验证是否能ping通虚拟机端 f）ping通后，输入指令 1nano ~&#x2F;.bashrc 最下面修改两行：（IP地址是小车端） 12export ROS_MASTER_URI&#x3D;http:&#x2F;&#x2F;192.168.0.109:11311export ROS_HOSTNAME&#x3D;192.168.0.109 保存即可。 4.配置ssh免密登录a）首先,在本地计算机生成公钥和私钥。打开终端,执行命令: 1ssh-keygen 一直按回车键选择默认选项,会在~/.ssh 目录下生成 id_rsa 和 id_rsa.pub 两个文件。然后将 id_rsa.pub 文件复制到远程计算机: 1scp ~&#x2F;.ssh&#x2F;id_rsa.pub username@ip_address:&#x2F;home&#x2F;username 本机中，所用命令为scp ~/.ssh/id_rsa.pub nodes@192.168.1.109:/home/nodes b）将公钥文件 id_rsa.pub 拷贝到远程计算机后,SSH 登录到远程计算机: 1ssh username@ip_address 其中 username 为远程计算机用户名,ip_address 为远程计算机的 IP 地址。 c）登录后,将id_rsa.pub 的文件内容追加写入到远程计算机的~/.ssh/authorized_keys 文件中,并修改 authorized_keys 文件的权限: 12$ cat id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys$ chmod 600 ~&#x2F;.ssh&#x2F;authorized_keys 配置完成后,再登录远程计算机就无需输入密码。 d）接下来,即可配置 RoboWare Studio的远程调试参数进行远程调试修改远程计算机/etc/profile首先,登录远程计算机: 1$ ssh username@ip_address 登录后,切换到 root 用户权限,将 ROS 环境变量信息写入到/etc/profile 文件中: 12$ sudo su$ echo &quot;source &#x2F;opt&#x2F;ros&#x2F;indigo&#x2F;setup.bash&quot; &gt;&gt; &#x2F;etc&#x2F;profile 接下来在roboware上配置远程主控信息 步骤：IP，用户名（nodes），一直敲回车就可以了。 二、调试及运行1.基本模块的配置 GY85（方向位置模块） 开启I2C： 1sudo raspi-config 选择3 Interfacing Options 选择P4 没有在/dev/目录下发现i2c-x的设备，这个时候需要做以下操作(1) 添加i2c模块 1sudo nano &#x2F;etc&#x2F;modules 然后添加以下两行内容 12i2c-bcm2708 i2c-dev 再次reboot，就可以看见了。 (2) 安装i2c工具，查看i2c设备 1sudo apt-get install i2c-tools 提供以下i2c的工具命令，如i2cdetect，i2cget，i2cset等。 (3) 执行命令查看i2c设备 1sudo i2cdetect -y 1 GY85连线方式 github源码下载https://github.com/RigacciOrg/py-qmc5883l 安装： 1sudo python setup.py install GPS模块 数据线连接GPS /ttyACM0 输入lsusb找到设备ID ID后面的1546对应着idVendor，01a7对应idProduct 在/etc/udev/rules.d/，找到规则文件xrobot-usb.rules，加入一下文字 1KERNEL&#x3D;&#x3D;&quot;ttyACM?&quot;, ATTRS&#123;idVendor&#125;&#x3D;&#x3D;&quot;1546&quot;, ATTRS&#123;idProduct&#125;&#x3D;&#x3D;&quot;01a7&quot;, MODE&#x3D;&quot;0666&quot; SYMLINK+&#x3D;&quot;gps&quot; 通过minicom获取串口数据 12sudo apt-get install minicomminicom -b 9600 -o -D &#x2F;dev&#x2F;gps 获取的数据 测试代码 1234567891011121314151617import mathimport serial #导入serial模块#定义读取坐标函数def data_gps(): ser = serial.Serial(&quot;/dev/ttyUSB0&quot;,9600) data = [] line = str(str(ser.readline())[2:]) if line.startswith(&#x27;$GNGGA&#x27;): print(&#x27;接收的数据：&#x27;+str(line)) line = str(line).split(&#x27;,&#x27;) jing = float(line[4][:-7])+float(line[4][-7:])/60 wei = float(line[2][:-7])+float(line[2][-7:])/60 data.append(jing) data.append(wei) return float(data[0]),float(data[1]) 若有数据返回，即可使用。 注：在运行过程中会出现获取不到数据的情况（数据内部为空值），若获取不到数据，建议选取空旷地带，受信号干扰小的地方进行测试（本人在实验室和宿舍测试过程中，数据总断断续续） 附三个相关链接： https://www.cnblogs.com/wjyHIT2011/articles/6795249.html https://blog.csdn.net/weixin_44524040/article/details/90215917 https://www.cnblogs.com/hangxin1940/archive/2013/04/02/2997077.html DHT11（温湿度模块） 引脚配置及连接 树莓派3B引脚图： 传感器模块图： 连接方式： VCC（或正极） — 树莓派的3v电源 GND （地线或者负极）— 树莓派的GND接口 DATA （D或者out） —树莓派的GPIO引脚 连接好后，测试 python使用的是RPi.gpio库来控制引脚，这个库在树莓派里面已经导入了 ，直接使用即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import RPi.GPIO as GPIOimport time channel =4 //引脚号，具体接口看上图配置data = []j = 0 GPIO.setmode(GPIO.BCM)//编码方式 time.sleep(1) GPIO.setup(channel, GPIO.OUT)GPIO.output(channel, GPIO.LOW)time.sleep(0.02)GPIO.output(channel, GPIO.HIGH)GPIO.setup(channel, GPIO.IN) while GPIO.input(channel) == GPIO.LOW: continuewhile GPIO.input(channel) == GPIO.HIGH: continue while j &lt; 40: k = 0 while GPIO.input(channel) == GPIO.LOW: continue while GPIO.input(channel) == GPIO.HIGH: k += 1 if k &gt; 100: break if k &lt; 8: data.append(0) else: data.append(1) j += 1 print &quot;sensor is working.&quot;print data humidity_bit = data[0:8]humidity_point_bit = data[8:16]temperature_bit = data[16:24]temperature_point_bit = data[24:32]check_bit = data[32:40] humidity = 0humidity_point = 0temperature = 0temperature_point = 0check = 0 for i in range(8): humidity += humidity_bit[i] * 2 ** (7-i) humidity_point += humidity_point_bit[i] * 2 ** (7-i) temperature += temperature_bit[i] * 2 ** (7-i) temperature_point += temperature_point_bit[i] * 2 ** (7-i) check += check_bit[i] * 2 ** (7-i) tmp = humidity + humidity_point + temperature + temperature_point if check == tmp: print &quot;temperature :&quot;, temperature, &quot;*C, humidity :&quot;, humidity, &quot;%&quot;else: print &quot;wrong&quot; print &quot;temperature :&quot;, temperature, &quot;*C, humidity :&quot;, humidity, &quot;% check :&quot;, check, &quot;, tmp :&quot;, tmp GPIO.cleanup() 这里要注意，编码方式和引脚号 （1）编码方式：PR库有两种方式，一种是bcm另一种是wiringPi的方式，两者的区别大致是bcm的的pin的序号0，1，3，。。。是与每一个gpio引脚对应的，不包含gnd和电源之类的在内，而wiringPi则是从电源开始为0，然后按增序排。使用python的脚本，只需要在setmode函数里面制定编码方式即可。 （2）引脚号：程序里面用的是bcm的4号（即channel变量），注意连线方式是否与代码匹配。 结果图如下： 附参考链接： https://blog.csdn.net/u010900754/article/details/53078615?locationNum=13&amp;fps=1 https://blog.csdn.net/wc810267705/article/details/79586481?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control https://blog.csdn.net/weixin_39289876/article/details/105268867?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.control USB摄像头 本地监控（使用motion模块） 具体配置： 1）安装motion 1sudo apt-get install motion 2）配置 1sudo nano &#x2F;etc&#x2F;default&#x2F;motion 将里面的no修改成yes，让motion可以一直在后台运行 1start_motion_daemon&#x3D;yes 然后打开配置文件 1sudo nano &#x2F;etc&#x2F;motion&#x2F;motion.conf 找到相关配置修改： 1234567daemon on #off改成onwidth 800 height 600 #根据摄像头像素自行更改framerate 60 #这个代表帧率，50左右效果还行，可根据效果自行更改stream_localhost off #设为offstream_port 8081stream_maxrate 100 #关键配置，更改后流畅 3）启动motion 1sudo motion 4）查看视频数据 局域网内的设备打开浏览器访问树莓派IP:8081即可实现。 5）退出motion 12sudo killall -TERM motion或service motion stop 相关链接： https://www.jb51.net/article/163690.htm https://blog.csdn.net/qq_18471449/article/details/104119071 使用udp协议传输视频帧上传服务器在线监控（opencv+python） 首先测试能否顺利调用摄像头： 终端中输入： 123python &#x2F;&#x2F;确认python版本uname -a &#x2F;&#x2F;确认OS版本lsb_release -a 安装OpenCV和Python版的OpenCV安装包 12sudo apt-get install libopencv-devsudo apt-get install python-opencv 测试代码 12345678910111213141516import cv2#初期化USB摄像头cap = cv2.VideoCapture(0)while( cap.isOpened() ): #USB摄像头工作时,读取一帧图像 ret, frame = cap.read() #显示图像窗口在树莓派的屏幕上 cv2.imshow(&#x27;Capture&#x27;,frame) #按下q键退出 key = cv2.waitKey(1) #print( &#x27;%08X&#x27; % (key&amp;0xFFFFFFFF) ) if key &amp; 0x00FF == ord(&#x27;q&#x27;): break# 释放资源和关闭窗口cap.release()cv2.destroyAllWindows() 测试输出： 若测试成功，即可进行UDP传输，相关原理如下： 视频传输用UDP还是TCP ​ 首先考虑用哪种传输方式，平常TCP用的非常多，但是像视频帧这种数据用TCP不是太合适，因为视频数据的传输最先要考虑的是速度而不是准确性，视频帧的数据量很大，帧间隔也非常短，需要尽量保证传输速度，同时丢失一些数据是无所谓的。TCP需要维护连接、保证数据包正确，会耗费一些时间，因此应该使用UDP，就像所有参考书上说的，UDP不在乎是否建立连接，也不管数据是否能被准确接收，只关心能否把数据发送出去而已。 ​ 在Python的socket代码中也可直观地看到UDP的特点，对于发送方，我们通过server=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)创建UDP套接字对象，然后执行server.connect((HOST,PORT)) 指定发送方地址，但其实connect函数直接就返回了，不像TCP中的客户端会等待连接成功，接着就可直接在套接字对象上调用send函数发送数据了，这个过程根本没确立连接。 图像传输中的编解码 ​ 用UDP传输图像有一个很关键的问题需要考虑，就是图像的大小。根据UDP协议，单个包的数据大小最大只能65507个字节（去掉包头），而一般直接从摄像头采集的图像帧的大小比这个数要大得多，以我的逻辑C270为例，单幅图像的大小为480X640X3个字节，远大于65507，因此一个包是没法发送完的。解决方法有两种，一种是把图像拆成几次进行发送，相应的接收端用个循环多次接收，这种方法可以完整地接收数据，但是速度肯定受到影响，而且可能要添加一些自定义规则，徒增麻烦；另一种方法就是发送前先对图像进行编码压缩，接收后再解码，清晰度会有所下降，但是可以保持速度上的优势，这种方式比较合适。 ​ OpenCV中的imencode和imdecode方法可分别用于图像的编码和解码。imencode根据指定的标识将图像数据编码并存入缓存区，函数原型为cv2.imencode(ext, img[, params]) → retval, buf，ext为文件扩展名，指定了存储格式，如’.jpg’；img为需要编码的图像数据； params为指定的编码标识，其形式为paramId_1, paramValue_1, paramId_2, paramValue_2, ... ，对于jpg格式，可以指定标识为CV_IMWRITE_JPEG_QUALITY ，其对应的值在0到100之间，表示了压缩质量，值越大压缩率越大，编码后的数据量越小，但解码后的图像质量也越差。imdecode从缓存区读取图像数据，通过指定标识，可以实现指定的解码格式。imdecode的函数原型为cv2.imdecode(buf, flags) → retval ，其中flags指定图像的读取类型，实际上就是指定了以多少深度多少通道读取图像，比如CV_LOAD_IMAGE_ANYDEPTH（即整数2）表示单个通道，深度不变的灰度图；CV_LOAD_IMAGE_COLOR（即整数1）表示3通道、8位深度的彩色图。 结合套接字对象和编解码函数，就可以编写发送端的代码了，不过还有一个需要注意的地方是发送和接收的数据格式问题，套接字的发送和接收都是字节流，或者说是byte数组，发送数据时需要以字节流格式发送，接收数据后需要把字节流类型转换成合适的数据类型。 从摄像头获取的图像是480X640X3的numpy.ndarray类型，通过imencode编码，得到？X1的numpy.ndarray对象，经测试，这个对象可以直接发送出去；在接收端，获得的是byte数组，这个数组直接做imdecode的参数会报错，经调试，发现还需要把数组转换成numpy.ndarray类型。 树莓派端代码如下： 12345678910111213141516171819202122import cv2import numpyimport socketimport structHOST=&#x27;192.168.1.122&#x27;PORT=9999server=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #socket对象server.connect((HOST,PORT))print(&#x27;now starting to send frames...&#x27;)capture=cv2.VideoCapture(0) #VideoCapture对象，可获取摄像头设备的数据try: while True: success,frame=capture.read() result,imgencode=cv2.imencode(&#x27;.jpg&#x27;,frame,[cv2.IMWRITE_JPEG_QUALITY,50]) #编码 server.sendall(struct.pack(&#x27;i&#x27;,imgencode.shape[0])) #发送编码后的字节长度，这个值不是固定的 server.sendall(imgencode) #发送视频帧数据 print(&#x27;have sent one frame&#x27;)except Exception as e: print(e) server.sendall(struct.pack(&#x27;c&#x27;,1)) #发送关闭消息 capture.release() server.close() 服务器端代码如下： 12345678910111213141516171819202122232425262728293031import cv2import numpyimport socketimport structHOST=&#x27;192.168.191.122&#x27;PORT=9999buffSize=65535server=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) #创建socket对象server.bind((HOST,PORT))print(&#x27;now waiting for frames...&#x27;)while True: data,address=server.recvfrom(buffSize) #先接收的是字节长度 if len(data)==1 and data[0]==1: #如果收到关闭消息则停止程序 server.close() cv2.destroyAllWindows() exit() if len(data)!=4: #进行简单的校验，长度值是int类型，占四个字节 length=0 else: length=struct.unpack(&#x27;i&#x27;,data)[0] #长度值 data,address=server.recvfrom(buffSize) #接收编码图像数据 if length!=len(data): #进行简单的校验 continue data=numpy.array(bytearray(data)) #格式转换 imgdecode=cv2.imdecode(data,1) #解码 print(&#x27;have received one frame&#x27;) cv2.imshow(&#x27;frames&#x27;,imgdecode) #窗口显示 if cv2.waitKey(1)==27: #按下“ESC”退出 breakserver.close()cv2.destroyAllWindows() 测试验证 使用本地客户端可以流畅显示，服务器端还未对接，之后贴图。 相关链接： https://www.jb51.net/article/174308.htm https://www.jb51.net/article/163696.htm 2.小车运动模块代码详解 键盘控制 a）小车端：输入指令 1roslaunch xrobot_base xrobot_odom_encoder.launch b）虚拟机端： 12roscorerosrun teleop_twist_keyboard teleop_twist_keyboard.py teleop_twist_keyboard.py具体源码如下：(建议从github下clone下来) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#!/usr/bin/env pythonfrom __future__ import print_functionimport roslib; roslib.load_manifest(&#x27;teleop_twist_keyboard&#x27;)import rospyfrom geometry_msgs.msg import Twistimport sys, select, termios, ttymsg = &quot;&quot;&quot;Reading from the keyboard and Publishing to Twist!---------------------------Moving around: u i o j k l m , .For Holonomic mode (strafing), hold down the shift key:--------------------------- U I O J K L M &lt; &gt;t : up (+z)b : down (-z)anything else : stopq/z : increase/decrease max speeds by 10%w/x : increase/decrease only linear speed by 10%e/c : increase/decrease only angular speed by 10%CTRL-C to quit&quot;&quot;&quot;moveBindings = &#123; &#x27;i&#x27;:(1,0,0,0), &#x27;o&#x27;:(1,0,0,-1), &#x27;j&#x27;:(0,0,0,1), &#x27;l&#x27;:(0,0,0,-1), &#x27;u&#x27;:(1,0,0,1), &#x27;,&#x27;:(-1,0,0,0), &#x27;.&#x27;:(-1,0,0,1), &#x27;m&#x27;:(-1,0,0,-1), &#x27;O&#x27;:(1,-1,0,0), &#x27;I&#x27;:(1,0,0,0), &#x27;J&#x27;:(0,1,0,0), &#x27;L&#x27;:(0,-1,0,0), &#x27;U&#x27;:(1,1,0,0), &#x27;&lt;&#x27;:(-1,0,0,0), &#x27;&gt;&#x27;:(-1,-1,0,0), &#x27;M&#x27;:(-1,1,0,0), &#x27;t&#x27;:(0,0,1,0), &#x27;b&#x27;:(0,0,-1,0), &#125;speedBindings=&#123; &#x27;q&#x27;:(1.1,1.1), &#x27;z&#x27;:(.9,.9), &#x27;w&#x27;:(1.1,1), &#x27;x&#x27;:(.9,1), &#x27;e&#x27;:(1,1.1), &#x27;c&#x27;:(1,.9), &#125;def getKey(): tty.setraw(sys.stdin.fileno()) select.select([sys.stdin], [], [], 0) key = sys.stdin.read(1) termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings) return keydef vels(speed,turn): return &quot;currently:\\tspeed %s\\tturn %s &quot; % (speed,turn)if __name__==&quot;__main__&quot;: settings = termios.tcgetattr(sys.stdin) pub = rospy.Publisher(&#x27;cmd_vel&#x27;, Twist, queue_size = 1) rospy.init_node(&#x27;teleop_twist_keyboard&#x27;) speed = rospy.get_param(&quot;~speed&quot;, 0.5) turn = rospy.get_param(&quot;~turn&quot;, 1.0) x = 0 y = 0 z = 0 th = 0 status = 0 try: print(msg) print(vels(speed,turn)) while(1): key = getKey() if key in moveBindings.keys(): x = moveBindings[key][0] y = moveBindings[key][1] z = moveBindings[key][2] th = moveBindings[key][3] elif key in speedBindings.keys(): speed = speed * speedBindings[key][0] turn = turn * speedBindings[key][1] print(vels(speed,turn)) if (status == 14): print(msg) status = (status + 1) % 15 else: x = 0 y = 0 z = 0 th = 0 if (key == &#x27;\\x03&#x27;): break twist = Twist() twist.linear.x = x*speed; twist.linear.y = y*speed; twist.linear.z = z*speed; twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = th*turn pub.publish(twist) except Exception as e: print(e) finally: twist = Twist() twist.linear.x = 0; twist.linear.y = 0; twist.linear.z = 0 twist.angular.x = 0; twist.angular.y = 0; twist.angular.z = 0 pub.publish(twist) termios.tcsetattr(sys.stdin, termios.TCSADRAIN, settings) 即可实现键盘控制，具体操作如下图： I 前进 &lt; 后退 J 左转 L 右转U 左转前进 O 右转前进 M 左转后退 &gt;右转后退 每按一次，XRobot 只会执行指令 1 秒就会停止。 如果无反应，需要等待数据同步后重试，若不行，重启即可。 自动避障（由陈硕学长编写实现） 具体实现自动行驶及避障功能（代码优化还未实现） 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;boost/thread.hpp&gt;#include &quot;sensor_msgs/LaserScan.h&quot;#include&lt;iostream&gt;#include &quot;math.h&quot;#include &lt;string.h&gt;#include &lt;list&gt;#include &lt;boost/algorithm/string.hpp&gt;#include &quot;geometry_msgs/Twist.h&quot;#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;valarray&gt;using namespace std;#define RAD2DEG(x) ((x)*180./M_PI)#define pi 3.1415926535897932384626433832795#define EARTH_RADIUS 6378.137 //地球半径 KMstruct latlon&#123; float lat; float lon;&#125;;double rad(double d)&#123; return d * pi /180.0;&#125;//距离double RealDistance(double lat1,double lng1,double lat2,double lng2)//lat1第一个点纬度,lng1第一个点经度,lat2第二个点纬度,lng2第二个点经度&#123; double a; double b; double radLat1 = rad(lat1); double radLat2 = rad(lat2); a = radLat1 - radLat2; b = rad(lng1) - rad(lng2); double s = 2 * asin(sqrt(pow(sin(a/2),2) + cos(radLat1)*cos(radLat2)*pow(sin(b/2),2))); s = s * EARTH_RADIUS; s = s * 1000; return s;&#125;//方向int get_angle(double lat1, double lng1, double lat2, double lng2)&#123; double lat1_rad = lat1 * pi /180; double lng1_rad = lng1 * pi /180; double lat2_rad = lat2 * pi /180; double lng2_rad = lng2 * pi /180; double x = sin(lng2_rad - lng1_rad) * cos(lat2_rad); double y = cos(lat1_rad) * sin(lat2_rad) - sin(lat1_rad) * cos(lat2_rad) * cos(lng2_rad - lng1_rad); float brng = atan2(x,y) * 180 / pi; int fangxiang = brng + 360; return fangxiang % 360;&#125;class multiThreadListener&#123; public: multiThreadListener() &#123; cmd_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;auto_vel&quot;,50); GPS = n.subscribe(&quot;GPS&quot;, 50, &amp;multiThreadListener::get_gps,this); GY85 = n.subscribe(&quot;GY85&quot;, 50, &amp;multiThreadListener::get_gy85,this); Lidar = n.subscribe(&quot;scan&quot;, 1000, &amp;multiThreadListener::get_lidar,this); route = n.subscribe(&quot;send_route&quot;,50, &amp;multiThreadListener::get_route, this); &#125; void get_gps(const std_msgs::String::ConstPtr&amp; msg); void get_gy85(const std_msgs::String::ConstPtr&amp; msg); void get_lidar(const sensor_msgs::LaserScan::ConstPtr&amp; scan); void get_route(const std_msgs::String::ConstPtr&amp; msg); void move(); private: ros::NodeHandle n; ros::Subscriber GPS; ros::Subscriber GY85; ros::Subscriber Lidar; ros::Subscriber route; ros::Publisher cmd_pub; list&lt;latlon&gt; Mul_gps; list&lt;latlon&gt; path; //路径信息 latlon runtime_gps;//实时GPS信息 float car_direction; //实时方向 float new_liadr[90]; //雷达数据 &#125;;/*获取GPS实时数据*/void multiThreadListener::get_gps(const std_msgs::String::ConstPtr&amp; msg)&#123; //ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str()); vector&lt;string&gt; vec; boost::split(vec, msg-&gt;data,boost::is_any_of(&quot;,&quot;), boost::token_compress_on); runtime_gps.lat = atof(vec[0].c_str()); runtime_gps.lon = atof(vec[1].c_str()); // printf(&quot;%f %f\\n&quot;,runtime_gps.lon,runtime_gps.lat); // ros::Rate loop_rate(0.5);//block chatterCallback2() // loop_rate.sleep();&#125;/*获取GY85车头实时方向数据*/void multiThreadListener::get_gy85(const std_msgs::String::ConstPtr&amp; msg)&#123; //ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str()); //car_direction = atof(msg-&gt;data.c_str()); int direction = atof(msg-&gt;data.c_str()) - 25; if(direction &gt;=0)&#123; car_direction = direction; &#125;else&#123; car_direction = direction + 360; &#125; // printf(&quot;%d\\n&quot;,car_direction);&#125;/*获取雷达实时数据*/void multiThreadListener::get_lidar(const sensor_msgs::LaserScan::ConstPtr&amp; scan)&#123; for(int i = 0; i &lt; 90; i++) &#123; new_liadr[i] = scan-&gt;ranges[i+135]; //printf(&quot;%f \\n&quot;,new_liadr[i]); &#125;&#125;/*获取规划的路径信息*/void multiThreadListener::get_route(const std_msgs::String::ConstPtr&amp; msg)&#123; latlon position; path.clear(); if((msg-&gt;data).length()!=0)&#123; vector&lt;string&gt; vec; boost::split(vec, msg-&gt;data,boost::is_any_of(&quot;,&quot;), boost::token_compress_on); for(int i = 0; i &lt; vec.size(); ++i) &#123; if(i%2 == 0)&#123; position.lon = atof(vec[i].c_str()); &#125;else if(i%2 == 1)&#123; position.lat = atof(vec[i].c_str()); path.push_back(position); &#125; &#125; &#125;&#125;void multiThreadListener::move()&#123; int i = 0; int last_min = -1; geometry_msgs::Twist msg; for(int j = 0; j &lt; 90; j++)&#123; new_liadr[j] = 0.8; &#125; while(true)&#123; //printf(&quot;move %d\\n&quot;,path.size()); if(path.size()!=0)&#123; latlon next_Destination = path.front();//下一目标点 //printf(&quot;next_Destination %f %f\\n&quot;,next_Destination.lat,next_Destination.lon); int move_direction = get_angle(runtime_gps.lat,runtime_gps.lon,next_Destination.lat,next_Destination.lon);//应该前进运动的方向，与车实时的方向不同 //printf(&quot;move_direction %d\\n&quot;,move_direction); if(RealDistance(runtime_gps.lat,runtime_gps.lon,next_Destination.lat,next_Destination.lon)&lt;=4)&#123; path.pop_front(); &#125; float min = *min_element(new_liadr,new_liadr + sizeof(new_liadr)/sizeof(new_liadr[0])); int min_index = distance(new_liadr, min_element(new_liadr, new_liadr + sizeof(new_liadr)/sizeof(new_liadr[0]))); if(min &lt;= 0.4)&#123; if(min_index &gt;=0 &amp;&amp; min_index &lt;=45 &amp;&amp; (last_min == -1 || (last_min &gt;= 0 &amp;&amp; last_min &lt;=45)) &amp;&amp; i &lt; 2)&#123; msg.linear.x = 0; msg.angular.z = 0.4; &#125;else if(min_index &gt; 45 &amp;&amp; min_index &lt; 90 &amp;&amp; (last_min == -1 || (last_min &gt; 45 &amp;&amp; last_min &lt; 90)) &amp;&amp; i &lt; 2)&#123; msg.linear.x = 0; msg.angular.z = -0.4; &#125;else if(min_index &gt;=0 &amp;&amp; min_index &lt;=45 &amp;&amp; (last_min &gt; 45 &amp;&amp; last_min &lt; 90) &amp;&amp; i &lt; 2)&#123; msg.linear.x = 0; msg.angular.z = 0.4; i++; &#125;else if(min_index &gt; 45 &amp;&amp; min_index &lt; 90 &amp;&amp; (last_min &gt;= 0 &amp;&amp; last_min &lt;= 45) &amp;&amp; i &lt; 2)&#123; msg.linear.x = 0; msg.angular.z = -0.4; i++; &#125;else if(i &gt;= 2)&#123; msg.linear.x = 0; msg.angular.z = -0.4; &#125; last_min = min_index; &#125; else&#123; i = 0; if((car_direction - move_direction &lt;= 150 &amp;&amp; car_direction - move_direction &gt; 1) || (car_direction - move_direction +360 &lt;= 150 &amp;&amp; car_direction - move_direction +360 &gt; 1))&#123; msg.linear.x = 0.2; msg.angular.z = 0.2; &#125;else if((car_direction - move_direction &lt; -1 &amp;&amp; car_direction - move_direction &gt;= -150) || (car_direction - move_direction -360 &lt;= -1 &amp;&amp; car_direction - move_direction -360 &gt;= -150))&#123; msg.linear.x = 0.2; msg.angular.z = -0.2; &#125;else if(car_direction - move_direction == 0)&#123; msg.linear.x = 0.3; msg.angular.z = 0; &#125;else&#123; msg.linear.x = 0; msg.angular.z = -0.4; &#125; &#125; printf(&quot;msg %d %f %f %f\\n&quot;,move_direction,car_direction,msg.linear.x,msg.angular.z); cmd_pub.publish(msg); &#125; sleep(1); &#125;&#125;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;multi_sub&quot;); multiThreadListener listener_obj; ros::AsyncSpinner spinner(4); // Use 2 threads spinner.start(); listener_obj.move(); ros::waitForShutdown(); return 0;&#125; 前端控制（学长学姐已实现，我们正在调试） 核心就是前端点击前进后退等，小车接收到数据实现运动。 附核心代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/******************************************************************基于串口通信的ROS小车基础控制器，功能如下：1.实现ros控制数据通过固定的格式和串口通信，从而达到控制小车的移动2.订阅了/cmd_vel主题，只要向该主题发布消息，就能实现对控制小车的移动3.发布里程计主题/odm串口通信说明：1.写入串口（1）内容：左右轮速度，单位为mm/s（2）格式：１０字节,[右轮速度４字节][左轮速度４字节][结束符&quot;\\r\\n&quot;２字节]2.读取串口（1）内容：小车x,y坐标，方向角，线速度，角速度，单位依次为：mm,mm,rad,mm/s,rad/s（2）格式：２１字节，[Ｘ坐标４字节][Ｙ坐标４字节][方向角４字节][线速度４字节][角速度４字节][结束符&quot;\\n&quot;１字节]*******************************************************************/#include&quot;ros/ros.h&quot;#include&quot;geometry_msgs/Twist.h&quot; #include &quot;std_msgs/String.h&quot; //包含geometry_msgs::Twist消息头文件#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/shm.h&gt;#include &lt;sys/time.h&gt;#include &lt;unistd.h&gt; class Joy_controller&#123;public: Joy_controller()&#123; cmd_pub = n.advertise&lt;geometry_msgs::Twist&gt;(&quot;joy_vel&quot;,50); joy_sub = n.subscribe(&quot;recv_joy&quot;, 10, &amp;Joy_controller::chatterCallback,this); &#125; void chatterCallback(const std_msgs::String::ConstPtr&amp; recv_msg)&#123; geometry_msgs::Twist send_msg; if(recv_msg-&gt;data==&quot;w&quot;)&#123; send_msg.linear.x = 0.3; &#125;else if(recv_msg-&gt;data==&quot;s&quot;)&#123; send_msg.linear.x = -0.3; &#125; if(recv_msg-&gt;data==&quot;a&quot;)&#123; send_msg.angular.z = 0.3; &#125;else if(recv_msg-&gt;data==&quot;d&quot;)&#123; send_msg.angular.z = -0.3; &#125; if(send_msg.linear.x!=0|| send_msg.angular.z!=0)&#123; cmd_pub.publish(send_msg); ROS_INFO(&quot;msg.linear.x:%f , msg.angular.z: %f&quot;,send_msg.linear.x,send_msg.angular.z); &#125; &#125;private: ros::NodeHandle n; ros::Publisher cmd_pub; ros::Subscriber joy_sub;&#125;;int main(int argc, char **argv)&#123; ros::init(argc, argv, &quot;joy_move&quot;);//turtle1/ Joy_controller Joy_controller; ros::spin(); return 0;&#125; 路径规划（还未实现，全部完成之后加入计划。） 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python#coding=utf-8import rospyimport timeimport mathimport serialimport urllibimport hashlibimport jsonimport requestsimport numpyfrom std_msgs.msg import Stringclass route: def __init__(self): self.sub = rospy.Subscriber(&quot;recv_gps&quot;, String, self.get_urt) self.pub = rospy.Publisher(&#x27;send_route&#x27;, String, queue_size=10) def get_urt(self, data): gps_data = data.data.split(&#x27;,&#x27;) #print(gps_data) #def get_urt(self,gps_first,gps_destination): # 以get请求为例http://api.map.baidu.com/geocoder/v2/?address=百度大厦&amp;output=json&amp;ak=你的ak #queryStr = &#x27;/geocoding/v3/?address=%s&amp;output=json&amp;ak=F6hU3hYMC7G0nIqi8DinyVeaCveTNUOD&#x27; % address queryStr = &#x27;/direction/v2/riding?origin=&#x27;+gps_data[0]+&#x27;,&#x27;+gps_data[1]+&#x27;&amp;destination=&#x27;+gps_data[3]+&#x27;,&#x27;+gps_data[2]+&#x27;&amp;ak=F6hU3hYMC7G0nIqi8DinyVeaCveTNUOD&#x27; #queryStr = &#x27;/direction/v2/riding?origin=&#x27;+gps_data[0]+&#x27;,&#x27;+gps_data[1]+&#x27;&amp;destination=30.317174,120.349711&amp;ak=F6hU3hYMC7G0nIqi8DinyVeaCveTNUOD&#x27; # 对queryStr进行转码，safe内的保留字符不转换 encodedStr = urllib.quote(queryStr, safe=&quot;/:=&amp;?#+!$,;&#x27;@()*[]&quot;) # 在最后直接追加上yoursk rawStr = encodedStr + &#x27;fqB3atRGbBU4GXysiBMPRPZXq7fzDgWf&#x27; # 计算sn sn = (hashlib.md5(urllib.quote_plus(rawStr).encode(&quot;utf8&quot;)).hexdigest()) # 由于URL里面含有中文，所以需要用parse.quote进行处理，然后返回最终可调用的url url = urllib.quote(&quot;http://api.map.baidu.com&quot; + queryStr + &quot;&amp;sn=&quot; + sn, safe=&quot;/:=&amp;?#+!$,;&#x27;@()*[]&quot;) baidu_data = urllib.urlopen(url); hjson = json.loads(baidu_data.read()); if hjson[&#x27;status&#x27;] == 0: result = hjson[&#x27;result&#x27;]; routes = result[&#x27;routes&#x27;]; steps = routes[0][&#x27;steps&#x27;] path1 = steps[0][&#x27;path&#x27;]; real_path = [] for i in range(len(steps)): path1 = steps[i][&#x27;path&#x27;] path2 = path1.split(&#x27;;&#x27;) real_path.append(str(path2[len(path2)-1].split(&#x27;,&#x27;)[0])+&#x27;,&#x27;+str(path2[len(path2)-1].split(&#x27;,&#x27;)[1])) #real_path.append(path2[len(path2)-1].split(&#x27;,&#x27;)) if real_path != None: print(&quot;real_path: &quot;+str(real_path)) self.pub.publish(&quot;,&quot;.join(real_path))if __name__ == &#x27;__main__&#x27;: rospy.init_node(&#x27;route&#x27;, anonymous=False) route = route() rospy.spin() 3.网络协议部分详解 与服务器建立连接（TCP协议） 采用TCP协议保证连接的准确性和稳定性。 附客户端源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#!/usr/bin/env python# -*- coding: UTF-8 -*-import socketimport timeimport rospyimport threadingfrom std_msgs.msg import Stringrospy.init_node(&#x27;listener&#x27;, anonymous=True)destination = Nonegps_data =Nonesend_mulgps = rospy.Publisher(&#x27;recv_gps&#x27;, String, queue_size=10)send_joy = rospy.Publisher(&#x27;recv_joy&#x27;, String, queue_size=10)def callback(data): global gps_data gps_data = data.data print(data.data) print(&quot;gps_data:&quot;+gps_data)def listener(): rospy.Subscriber(&quot;GPS&quot;, String, callback) rospy.spin()if __name__ == &quot;__main__&quot;: global gps_data t = threading.Thread(target=listener) t.start() fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) fd.connect((&quot;175.24.59.243&quot;, 7002))//服务器，端口号 #fd.connect((&quot;127.0.0.1&quot;, 7002)) fd.send(bytes(&quot;1&quot;+&quot;\\n&quot;).encode(&quot;utf-8&quot;))//发送本机相关标识数据 while True: destination = fd.recv(1024) print(destination) if len(destination)&gt;1: print(str(gps_data)+&quot;,&quot;+str(destination)) send_mulgps.publish(str(gps_data)+&quot;,&quot;+str(destination)) destination =None elif len(destination)==1: send_joy.publish(str(destination)) destination =None fd.close() 传输数据（UDP协议） 传输数据需要尽量保证传输速度，采用UDP协议适于发送数据。 附客户端发送数据代码：（发送GPS，温湿度相关数据） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#!/usr/bin/env python# -*- coding: utf-8 -*-import socketimport osimport datetimeimport timeimport jsonimport randomimport rospyfrom std_msgs.msg import Stringip = &#x27;175.24.59.243&#x27;port = 10002s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)def callback(data): gps_data = data.data.split(&#x27;,&#x27;) currentTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime(time.time())) longitude = float(gps_data[1]) latitude = float(gps_data[0]) temperature = round(random.uniform(20, 40), 2) wind = round(random.uniform(0, 15), 2) humidity = round(random.uniform(0, 20), 2) sendData = &#123; &quot;time&quot;: currentTime, &#x27;code&#x27;: 2, &#x27;longitude&#x27;: longitude, &#x27;latitude&#x27;: latitude, &#x27;temperature&#x27;: temperature, &#x27;wind&#x27;: wind, &#x27;humidity&#x27;: humidity &#125; print(sendData) location = str(sendData) s.sendto(location, (ip, port))def listener(): rospy.init_node(&#x27;listener&#x27;, anonymous=True) rospy.Subscriber(&quot;GPS&quot;, String, callback)//订阅GPS数据，接收到发送回执 rospy.spin()if __name__ == &quot;__main__&quot;: listener() s.close() 暂时画下end。等与后端完全对接后，云平台测试再次续写。","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"ROS小车","slug":"ROS小车","permalink":"http://immnaruto.github.io/tags/ROS%E5%B0%8F%E8%BD%A6/"}]},{"title":"HDU操作系统实验二","slug":"HDU操作系统实验二","date":"2020-11-24T11:43:47.819Z","updated":"2020-11-26T02:50:00.479Z","comments":true,"path":"2020-11-24-HDU操作系统实验二.html","link":"","permalink":"http://immnaruto.github.io/2020-11-24-HDU%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C.html","excerpt":"HDU操作系统实验二一、实验要求1.设计一个模块，要求列出系统中所有内核线程的程序名、PID、进程状态、进程优先级、父进程的PID。 2.设计一个带参数的模块，其参数为某个进程的PID号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID号及进程状态。 3.进一步分析相关内核函数。","text":"HDU操作系统实验二一、实验要求1.设计一个模块，要求列出系统中所有内核线程的程序名、PID、进程状态、进程优先级、父进程的PID。 2.设计一个带参数的模块，其参数为某个进程的PID号，模块的功能是列出该进程的家族信息，包括父进程、兄弟进程和子进程的程序名、PID号及进程状态。 3.进一步分析相关内核函数。 二、实验思路1.第一个的整体思路是遍历各线程，通过用户地址标识符将内核线程和用户线程分开，通过pid进程描述符输出即可。 2.第二个实验要求需要在加载模块时提供对应pid传入参数，父进程和子进程直接遍历即可，兄弟进程稍微复杂些，需返回父进程的子进程的链表头字段，然后逐个遍历（排除传入pid的进程）。 三、实验步骤1.实验一要求较为简单，在内核目录下创建module1文件夹，新建module1.c和Makefile module1.c 12345678910111213141516171819202122232425262728293031#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/sched/signal.h&gt;// 初始化函数static int hello_init(void)&#123; struct task_struct *p; printk(KERN_ALERT&quot;\\t\\t名称\\t进程号\\t状态\\t优先级\\t&quot;); for_each_process(p) &#123; if(p-&gt;mm == NULL)&#123; //内核线程的mm成员为空 printk(KERN_ALERT&quot;%16s\\t%d\\t%ld\\t%d\\n&quot;,p-&gt;comm,p-&gt;pid, p-&gt;state,p-&gt;normal_prio); &#125; &#125; return 0;&#125;// 清理函数static void hello_exit(void)&#123; printk(KERN_ALERT&quot;goodbye!\\n&quot;);&#125;// 函数注册module_init(hello_init); module_exit(hello_exit); // 模块许可申明MODULE_LICENSE(&quot;GPL&quot;); Makefile 123456789obj-m:=module1.oKDIR:=/lib/modules/$(shell uname -r)/buildPWD:=$(shell pwd)default: $(MAKE) -C $(KDIR) M=$(PWD) modulesclean: $(MAKE) -C $(KDIR) M=$(PWD) clean 输入以下命令编译并加载模块，结果如下图所示。 1234make #编译sudo insmod module3.ko #加载模块lsmod #查看已加载的模块dmesg #输出日志信息 2.实验二与实验一类似，同样编写module2.c和Makefile module2.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/kernel.h&gt;#include &lt;linux/sched.h&gt;#include &lt;linux/moduleparam.h&gt;static pid_t pid=1;module_param(pid,int,0644);static int hello_init(void)&#123; struct task_struct *p; struct list_head *pp; struct task_struct *psibling; // 当前进程的 PID p = pid_task(find_vpid(pid), PIDTYPE_PID); printk(&quot;me: %d %s\\n&quot;, p-&gt;pid, p-&gt;comm); // 父进程 if(p-&gt;parent == NULL) &#123; printk(&quot;No Parent\\n&quot;); &#125; else &#123; printk(&quot;Parent: %d %s\\n&quot;, p-&gt;parent-&gt;pid, p-&gt;parent-&gt;comm); &#125; // 兄弟进程 list_for_each(pp, &amp;p-&gt;parent-&gt;children) &#123; psibling = list_entry(pp, struct task_struct, sibling); printk(&quot;sibling %d %s \\n&quot;, psibling-&gt;pid, psibling-&gt;comm); &#125; // 子进程 list_for_each(pp, &amp;p-&gt;children) &#123; psibling = list_entry(pp, struct task_struct, sibling); if (psibling-&gt;pid == pid) continue; printk(&quot;children %d %s \\n&quot;, psibling-&gt;pid, psibling-&gt;comm); &#125; return 0;&#125;static void hello_exit(void)&#123; printk(KERN_ALERT&quot;goodbye!\\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);MODULE_LICENSE(&quot;GPL&quot;); Makefile 123456789obj-m:=module2.oKDIR:=/lib/modules/$(shell uname -r)/buildPWD:=$(shell pwd)default: $(MAKE) -C $(KDIR) M=$(PWD) modulesclean: $(MAKE) -C $(KDIR) M=$(PWD) clean 同样地，输入以下命令编译并加载模块，结果如下图所示。 12345make #编译pstree -p #选择进程pidsudo insmod module2.ko pid&#x3D;1418 #加载模块lsmod #查看已加载的模块dmesg #输出日志信息 四、实验反思与总结1.判断内核线程：通过进程用户地址空间描述符来判断，内核线程的mm字段为NULL。 1struct mm_struct *mm #进程用户地址空间描述符 2.进程状态： **R(TASK_RUNNING)**，可执行状态。 只有在该状态的进程才可能在CPU上运行，同一时刻可能有多个进程处于可执行状态。 **S(TASK_INTERRUPTIBLE)**，可中断的睡眠状态。 处于这个状态的进程因为等待某事件的发生（比如等待socket连接、等待信号量），而被挂起。当这些事件发生时，对应的等待队列中的一个或多个进程将被唤醒。一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态。 **D(TASK_UNINTERRUPTIBLE)**，不可中断的睡眠状态。 与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的是进程不响应异步信号，无法用kill命令关闭处于TASK_UNINTERRUPTIBLE状态的进程。 **T(TASK_STOPPED or TASK_TRACED)**，暂停状态或跟踪状态。 向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。当进程正在被跟踪时，它处于TASK_TRACED状态。 **Z(TASK_DEAD - EXIT_ZOMBIE)**，退出状态。 进程在退出的过程中，处于TASK_DEAD状态，如果它的父进程没有收到SIGCHLD信号，故未调用wait（如wait4、waitid）处理函数等待子进程结束，又没有显式忽略该信号，它就一直保持EXIT_ZOMBIE状态。只要父进程不退出，这个EXIT_ZOMBIE状态的子进程就一直存在。 **X(TASK_DEAD - EXIT_DEAD)**，退出状态，进程即将被销毁。 EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。 3.优先级调度a）调度算法 ​ linux内核目前实现了6中调度策略(即调度算法), 用于对不同类型的进程进行调度, 或者支持某些特殊的功能，其中SCHED_NORMAL和SCHED_BATCH调度普通的非实时进程, SCHED_FIFO和SCHED_RR和SCHED_DEADLINE则采用不同的调度策略调度实时进程, SCHED_IDLE则在系统空闲时调用idle进程. 字段 描述 SCHED_NORMAL （也叫SCHED_OTHER）用于普通进程，通过CFS调度器实现。SCHED_BATCH用于非交互的处理器消耗型进程。SCHED_IDLE是在系统负载很低时使用 SCHED_BATCH SCHED_NORMAL普通进程策略的分化版本。采用分时策略，根据动态优先级(可用nice()API设置），分配CPU运算资源。注意：这类进程比上述两类实时进程优先级低，换言之，在有实时进程存在时，实时进程优先调度。但针对吞吐量优化, 除了不能抢占外与常规任务一样，允许任务运行更长时间，更好地使用高速缓存，适合于成批处理的工作 SCHED_IDLE 优先级最低，在系统空闲时才跑这类进程(如利用闲散计算机资源跑地外文明搜索，蛋白质结构分析等任务，是此调度策略的适用者） SCHED_FIFO 先入先出调度算法（实时调度策略），相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务 SCHED_RR 轮流调度算法（实时调度策略），后者提供 Roound-Robin 语义，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。不同要求的实时任务可以根据需要用sched_setscheduler() API设置策略 SCHED_DEADLINE 新支持的实时进程调度策略，针对突发型计算，且对延迟和完成时间高度敏感的任务适用。基于Earliest Deadline First (EDF) 调度算法 b）优先级定义 1234567#define MAX_NICE 19#define MIN_NICE -20#define NICE_WIDTH (MAX_NICE - MIN_NICE + 1)#define MAX_USER_RT_PRIO 100#define MAX_RT_PRIO MAX_USER_RT_PRIO#define MAX_PRIO (MAX_RT_PRIO + NICE_WIDTH)#define DEFAULT_PRIO (MAX_RT_PRIO + NICE_WIDTH / 2) ​ 程序的优先级范围为[0,139]，有效的实时优先级（RT priority）范围为[0,99]，SCHED_NORMAL和SCHED_BATCH这两个非实时任务的优先级为[100,139]。[100,139]这个区间的优先级又称为**静态优先级(static priority)**。之所以称为静态优先级是因为它不会随着时间而改变，内核不会修改它，只能通过系统调用nice去修改。静态优先级用进程描述符中的static_prio表示。优先级的值越低，表示具有更高的优先级，0的优先级最高。 优先级范围 描述 0——99 实时进程（RT priority）优先级范围 100——139 非实时进程（非实时调度器SCHED_NORMAL和SCHED_BATCH）优先级范围 ​ MAX_USER_RT_PRIO的值（默认为100）让用户态的优先级范围区别于实时优先级的最大值（99）。这样设计的好处是任何内核态线程的优先级都大于用户态的任务线程。注意：最大实时优先级（MAX_RT_PRIO）不得小于用户态优先级（MAX_USER_RT_PRIO）。 ​ 用户的nice值[-20,19]对应于静态优先级的[100,139]，也就是说，nice值越小，优先级越低。用户的nice值与优先级的转化关系为 12#define NICE_TO_PRIO(nice) ((nice) + DEFAULT_PRIO)#define PRIO_TO_NICE(prio) ((prio) - DEFAULT_PRIO) 可用下图来总结所对应的关系： 4.进程的task_struct结构及家族关系a）管理进程最重要的数据结构即为进程控制块（PCB），为task_struct类型的结构体，主要的相关标识符字段有： 12pid_t pid #进程标识符PIDpid_t tgid #线程组领头线程PID b）家族关系 除0号进程外，所有进程都是PID为1的init进程的后代。task_struct结构中描述家族关系主要字段有： 1234struct task_struct *real_parent #指向创建该进程的父进程struct task_struct *parent #指向该进程的当前父进程（一般与上面相同）struct list_head children #指向该进程子进程链表头部struct list_head sibling #指向兄弟进程链表中的下一个或前一个节点 由sibling字段链接成为父进程的children链表。 5.链表遍历进程原理1.list_for_each()和list_entry() 宏定义： 12#define list_for_each(pos, head) \\ for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next) 此定义只找到了list_head域的位置pos，通过list_entry()获得结构体起点地址。 12#define list_entry(ptr, type, member) \\ container_of(ptr, type, member) 其中ptr的值减去type结构体中member的偏移量，即可得出首地址。 2.for_each_process(p)和list_for_each_entry() 1234#define list_for_each_entry(pos, head, member) \\ for (pos &#x3D; list_first_entry(head, typeof(*pos), member); \\ &amp;pos-&gt;member !&#x3D; (head); \\ pos &#x3D; list_next_entry(pos, member)) 12#define for_each_process(p) for(p&#x3D;&amp;init_task; p&#x3D;next_task(p)!&#x3D;&amp;init_task) 可见，均为循环遍历链表算法。","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"超星跨文化交际题库查漏补缺","slug":"跨文化交际","date":"2020-11-18T02:50:53.495Z","updated":"2020-11-21T09:16:53.548Z","comments":true,"path":"2020-11-18-跨文化交际.html","link":"","permalink":"http://immnaruto.github.io/2020-11-18-%E8%B7%A8%E6%96%87%E5%8C%96%E4%BA%A4%E9%99%85.html","excerpt":"1 语境这一概念最早由波兰人类学家B.Malinowski在1923年提出来的。他将语境分为 情景 文化 语言交际分为口语交际和书面语交际。 下列属于高语境语言交际特点的是表情、空间、沉默 “西方乒乓球式”双向交际的表现是互动频繁 当面争执","text":"1 语境这一概念最早由波兰人类学家B.Malinowski在1923年提出来的。他将语境分为 情景 文化 语言交际分为口语交际和书面语交际。 下列属于高语境语言交际特点的是表情、空间、沉默 “西方乒乓球式”双向交际的表现是互动频繁 当面争执 2 在交际过程中不使用口头或文字形式进行信息传递的沟通方式即为非语言交际。 语言交际在人们面对面交际过程中仅占35%左右,其余65%主要是靠非语言交际手段来完成的。 在握手时，应由 女子; 主人; 年长者; 身份职位高者 先伸手。 文字 不属于非语言交际中的文化符号 韩国的公务聚会中应该首先给 职务最高者 敬酒 美国人的合适的社交距离 4-12英尺 3 在美国，百合象征着die 在美国猫头鹰代表着吉祥 X 表示“强壮”意思的英文表达是 as strong as a tiger 英文Don’t lie there. 双关 从传统上讲中国的春节是正月初一开始，一直延续到正月十五。 X 圣诞季节一般是从感恩节过后的“黑色星期五”开始，一直延续的第二年的元月15日 X 4西方人在旅游的时候，喜欢用相机去看，去记录。 X 习语的三个特征是语言整体性、结构凝固性和不可替代性。 慷慨准则是指 多称赞别人 在美国考驾照，倒车的时候要注意看倒视镜。 X 在英语里，“熊”意为聪明、伶俐。 5鸠摩罗什把佛教从西方引入中国，将大量经书翻译成汉语，为佛教在中国的传播做出了巨大的贡献。他与（ ）和玄奘并称为中国佛教四大译经家。 A. 不空 B. 鉴真 C. 法显 D. 真谛 AD 下面哪些属于中国八大建筑流派？ ABDE A. 江南民居 B. 川西民居 C. 蒙古包 D. 北京四合院 E. 书院建筑 中国古典建筑风格可以用以下哪12个字概括？ BCD A. 金碧辉煌 B. 雕梁画柱 C. 飞檐斗拱 D. 亭台楼阁 下面哪些建筑属于罗马式建筑？ A. 德国科隆大教堂 B. 伦敦圣保罗大教堂 C. 梵蒂冈圣保罗大教堂 D. 意大利米兰大教堂 E. 巴黎圣母院大教堂 正确答案B,C","categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"网课","slug":"网课","permalink":"http://immnaruto.github.io/tags/%E7%BD%91%E8%AF%BE/"}]},{"title":"我的博客","slug":"myblog","date":"2020-11-17T11:56:12.532Z","updated":"2020-11-23T14:27:49.829Z","comments":true,"path":"2020-11-17-myblog.html","link":"","permalink":"http://immnaruto.github.io/2020-11-17-myblog.html","excerpt":"","text":"写在开始 一点介绍你好，这里是Hai的BLOG，本人目前是计算机科学与技术专业的一枚大三弱鸡，杭电在读，打算考研。 搭建博客的初衷其实只是脑子一热，在查阅资料的时候看到了杭电学长搭建的博客非常nice，想着自己也可以尝试记录一些自己遇到的问题和经验分享，当然最主要的是给自己提供一个平台用来记录所学内容（老懒狗了），当然也会有一些生活点滴的分享（程序员嘛，不能太死宅），如果不嫌麻烦，就关注一下啦~:laughing: 从个人角度来说，想要快速进步最好的办法是实践，另外可以多写写博客看看博客（CSDN老选手了），记录自己遇到的种种问题，可以让我有动力继续学下去（虽然我觉得我是挺喜欢这个专业的，虽然遇到了很多困难和发现他没有我想的那么简单），另外在遇到各种困难查阅资料的时候，我发现很多基础的东西很难找到相关的教程，很难学懂，所以成长到正常实力其实还是要有很长很长很痛苦的路要走的，而如果我把其中的过程记录下来，或许也可以为和我一样情况，没有基础又找不到合适资料的人提供方便。 希望有朝一日，自己能成长起来，能做到自己想做的事情，看到曾经弱鸡的自己，露出一副欣慰的笑容哈哈哈哈，也希望能够和大家一同进步！ 暂时打算目前可能会在ROS机器人和Linux操作系统方向进行主要的学习。 PS：一些闲言碎语尽量不要三分钟热度…把自己所学的和所想的做好分享即可。","categories":[],"tags":[]}],"categories":[{"name":"学习","slug":"学习","permalink":"http://immnaruto.github.io/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://immnaruto.github.io/tags/HDU/"},{"name":"操作系统","slug":"操作系统","permalink":"http://immnaruto.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"生活","slug":"生活","permalink":"http://immnaruto.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://immnaruto.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"ROS小车","slug":"ROS小车","permalink":"http://immnaruto.github.io/tags/ROS%E5%B0%8F%E8%BD%A6/"},{"name":"网课","slug":"网课","permalink":"http://immnaruto.github.io/tags/%E7%BD%91%E8%AF%BE/"}]}